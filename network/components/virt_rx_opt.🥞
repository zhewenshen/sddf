/*
 * Copyright 2025, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */

#define CONFIG_DRIVER_ID         pnk_mem(0)
#define DRV_QUEUE_BASE           10
#define CLI_QUEUE_BASE           30
#define CLI_MAC_ADDR_BASE        100
#define DATA_IO_ADDR             200
#define DATA_REGION_VADDR        201
#define NUM_CLIENTS              202
#define BUFFER_REFS_BASE         210
#define CLI_CONN_ID_BASE         1210
#define NOTIFY_DRV_FLAG          1250
#define NOTIFY_CLIENTS_BASE      1260

#define BROADCAST_ID             -2
#define NET_BUFF_DESC_SIZE       16
#define MAX_INT16                65535

/* Global constants - loaded once at startup */
var 1 config_driver_id    = pnk_mem(CONFIG_DRIVER_ID);
var 1 num_clients         = pnk_mem(NUM_CLIENTS);
var 1 drv_active_queue    = pnk_mem(DRV_QUEUE_BASE + 1);
var 1 drv_capacity        = pnk_mem(DRV_QUEUE_BASE + 2);
var 1 drv_free_queue      = pnk_mem(DRV_QUEUE_BASE);
var 1 data_io_addr        = pnk_mem(DATA_IO_ADDR);
var 1 data_region_vaddr   = pnk_mem(DATA_REGION_VADDR);

#define NET_QUEUE_EMPTY(queue_ptr, capacity, result_out) \
  qe_tail = 0; \
  qe_head = 0; \
  !ld16 qe_tail, queue_ptr; \
  !ld16 qe_head, queue_ptr + 2; \
  qe_empty_check = qe_tail - qe_head; \
  result_out = (qe_empty_check == 0)

#define NET_DEQUEUE(queue_ptr, capacity, io_out, len_out) \
  dq_head = 0; \
  !ld16 dq_head, queue_ptr + 2; \
  dq_mod_head = dq_head & (capacity - 1); \
  dq_entry_addr = queue_ptr + 8 + dq_mod_head * NET_BUFF_DESC_SIZE; \
  !ldw io_out, dq_entry_addr; \
  !ld32 len_out, dq_entry_addr + 8; \
  dq_head = (dq_head + 1) & MAX_INT16; \
  !st16 queue_ptr + 2, dq_head

#define NET_ENQUEUE(queue_ptr, io_addr, len, capacity) \
  eq_tail = 0; \
  !ld16 eq_tail, queue_ptr; \
  eq_mod_tail = eq_tail & (capacity - 1); \
  eq_entry_addr = queue_ptr + 8 + eq_mod_tail * NET_BUFF_DESC_SIZE; \
  !stw eq_entry_addr, io_addr; \
  !st32 eq_entry_addr + 8, len; \
  eq_tail = (eq_tail + 1) & MAX_INT16; \
  !st16 queue_ptr, eq_tail

#define NET_REQUEST_SIGNAL(queue_ptr) \
  !st32 queue_ptr + 4, 0

#define NET_CANCEL_SIGNAL(queue_ptr) \
  !st32 queue_ptr + 4, 1

#define NET_REQUIRE_SIGNAL(queue_ptr, result_out) \
  rs_signalled = 0; \
  !ld32 rs_signalled, queue_ptr + 4; \
  result_out = !rs_signalled

fun rx_return() {
    var reprocess = 1;
    var client = 0;
    var i = 0;
    var notify_drv = 0;

    var local_num_clients        = num_clients;
    var local_drv_active_queue   = drv_active_queue;
    var local_drv_capacity       = drv_capacity;
    var local_drv_free_queue     = drv_free_queue;
    var local_data_io_addr       = data_io_addr;
    var local_data_region_vaddr  = data_region_vaddr;

    var qe_tail = 0;
    var qe_head = 0;
    var qe_empty_check = 0;
    var dq_head = 0;
    var dq_mod_head = 0;
    var dq_entry_addr = 0;
    var eq_tail = 0;
    var eq_mod_tail = 0;
    var eq_entry_addr = 0;
    var rs_signalled = 0;

    i = 0;
    while (i < local_num_clients) {
        var notify_addr = pnk_mem_ptr(NOTIFY_CLIENTS_BASE + i);
        !st32 notify_addr, 0;
        i = i + 1;
    }

    while (reprocess) {
        var drv_empty = 0;
        NET_QUEUE_EMPTY(local_drv_active_queue, local_drv_capacity, drv_empty);

        while (drv_empty == 0) {
            var io_offset = 0;
            var len = 0;
            NET_DEQUEUE(local_drv_active_queue, local_drv_capacity, io_offset, len);

            io_offset = io_offset - local_data_io_addr;
            var buffer_vaddr = io_offset + local_data_region_vaddr;

            cache_clean_and_invalidate(buffer_vaddr, buffer_vaddr + len)

            client = 0;
            var mac_matched = 0;

            while (client < local_num_clients && mac_matched == 0) {
                var match = 1;
                var mac_i = 0;

                while (mac_i < 6 && match) {
                    var dest_byte = 0;
                    var client_byte = pnk_mem(CLI_MAC_ADDR_BASE + client * 6 + mac_i);
                    !ld8 dest_byte, buffer_vaddr + mac_i;

                    if (dest_byte != client_byte) {
                        match = 0;
                    }
                    mac_i = mac_i + 1;
                }

                if (match) {
                    mac_matched = 1;
                } else {
                    client = client + 1;
                }
            }

            if (mac_matched == 0) {
                var broadcast = 1;
                var mac_i = 0;
                while (mac_i < 6 && broadcast) {
                    var dest_byte = 0;
                    !ld8 dest_byte, buffer_vaddr + mac_i;

                    if (dest_byte != 255) {
                        broadcast = 0;
                    }
                    mac_i = mac_i + 1;
                }

                if (broadcast) {
                    client = BROADCAST_ID;
                } else {
                    client = -1;
                }
            }

            if (client == BROADCAST_ID) {
                var ref_index = io_offset >> 11;
                var ref_addr = pnk_mem_ptr(BUFFER_REFS_BASE + ref_index);
                !st32 ref_addr, local_num_clients;

                i = 0;
                while (i < local_num_clients) {
                    var cli_queue_base = CLI_QUEUE_BASE + i * 4;
                    var cli_active_queue = pnk_mem(cli_queue_base + 1);
                    var cli_capacity = pnk_mem(cli_queue_base + 2);
                    NET_ENQUEUE(cli_active_queue, io_offset, len, cli_capacity);

                    var notify_addr = pnk_mem_ptr(NOTIFY_CLIENTS_BASE + i);
                    !st32 notify_addr, 1;
                    i = i + 1;
                }
            } else {
                if (client >= 0) {
                    var ref_index = io_offset >> 11;
                    var ref_addr = pnk_mem_ptr(BUFFER_REFS_BASE + ref_index);
                    !st32 ref_addr, 1;

                    var cli_queue_base = CLI_QUEUE_BASE + client * 4;
                    var cli_active_queue = pnk_mem(cli_queue_base + 1);
                    var cli_capacity = pnk_mem(cli_queue_base + 2);
                    NET_ENQUEUE(cli_active_queue, io_offset, len, cli_capacity);

                    var notify_addr = pnk_mem_ptr(NOTIFY_CLIENTS_BASE + client);
                    !st32 notify_addr, 1;
                } else {
                    io_offset = io_offset + local_data_io_addr;
                    NET_ENQUEUE(local_drv_free_queue, io_offset, len, local_drv_capacity);

                    notify_drv = 1;
                }
            }

            NET_QUEUE_EMPTY(local_drv_active_queue, local_drv_capacity, drv_empty);
        }

        NET_REQUEST_SIGNAL(local_drv_active_queue);
        reprocess = 0;

        NET_QUEUE_EMPTY(local_drv_active_queue, local_drv_capacity, drv_empty);
        if (drv_empty == 0) {
            NET_CANCEL_SIGNAL(local_drv_active_queue);
            reprocess = 1;
        }
    }

    client = 0;
    while (client < local_num_clients) {
        var notify_flag = pnk_mem(NOTIFY_CLIENTS_BASE + client);

        if (notify_flag) {
            var cli_queue_base = CLI_QUEUE_BASE + client * 4;
            var cli_active_queue = pnk_mem(cli_queue_base + 1);
            var cli_capacity = pnk_mem(cli_queue_base + 2);
            var signal_required = 0;
            NET_REQUIRE_SIGNAL(cli_active_queue, signal_required);

            if (signal_required) {
                NET_CANCEL_SIGNAL(cli_active_queue);
                var cli_conn_id = pnk_mem(CLI_CONN_ID_BASE + client);
                sddf_notify(cli_conn_id)
            }
        }
        client = client + 1;
    }

    if (notify_drv) {
        var signal_required = 0;
        NET_REQUIRE_SIGNAL(local_drv_free_queue, signal_required);

        if (signal_required) {
            NET_CANCEL_SIGNAL(local_drv_free_queue);
            sddf_deferred_notify(config_driver_id)
        }
    }

    return 0;
}

fun rx_provide() {
    var client = 0;
    var notify_drv = 0;

    var local_num_clients        = num_clients;
    var local_drv_free_queue     = drv_free_queue;
    var local_drv_capacity       = drv_capacity;
    var local_data_io_addr       = data_io_addr;

    var qe_tail = 0;
    var qe_head = 0;
    var qe_empty_check = 0;
    var dq_head = 0;
    var dq_mod_head = 0;
    var dq_entry_addr = 0;
    var eq_tail = 0;
    var eq_mod_tail = 0;
    var eq_entry_addr = 0;
    var rs_signalled = 0;

    while (client < local_num_clients) {
        var reprocess = 1;

        var cli_queue_base = CLI_QUEUE_BASE + client * 4;
        var cli_free_queue = pnk_mem(cli_queue_base);
        var cli_capacity = pnk_mem(cli_queue_base + 2);

        while (reprocess) {
            var cli_empty = 0;
            NET_QUEUE_EMPTY(cli_free_queue, cli_capacity, cli_empty);

            while (cli_empty == 0) {
                var io_offset = 0;
                var len = 0;
                NET_DEQUEUE(cli_free_queue, cli_capacity, io_offset, len);

                var aligned = (io_offset & 2047) == 0;
                var in_bounds = io_offset < (cli_capacity * 2048);

                if (aligned && in_bounds) {
                    var ref_index = io_offset >> 11;
                    var ref_count = pnk_mem(BUFFER_REFS_BASE + ref_index);

                    if (ref_count > 0) {
                        ref_count = ref_count - 1;
                        var ref_addr = pnk_mem_ptr(BUFFER_REFS_BASE + ref_index);
                        !st32 ref_addr, ref_count;

                        if (ref_count == 0) {
                            io_offset = io_offset + local_data_io_addr;
                            NET_ENQUEUE(local_drv_free_queue, io_offset, len, local_drv_capacity);

                            notify_drv = 1;
                        }
                    }
                }

                NET_QUEUE_EMPTY(cli_free_queue, cli_capacity, cli_empty);
            }

            NET_REQUEST_SIGNAL(cli_free_queue);
            reprocess = 0;

            NET_QUEUE_EMPTY(cli_free_queue, cli_capacity, cli_empty);
            if (cli_empty == 0) {
                NET_CANCEL_SIGNAL(cli_free_queue);
                reprocess = 1;
            }
        }
        client = client + 1;
    }

    if (notify_drv) {
        var signal_required = 0;
        NET_REQUIRE_SIGNAL(local_drv_free_queue, signal_required);

        if (signal_required) {
            NET_CANCEL_SIGNAL(local_drv_free_queue);
            sddf_deferred_notify(config_driver_id)
        }
    }

    return 0;
}

export fun notified(1 ch) {
    rx_return();
    rx_provide();

    return 0;
}
