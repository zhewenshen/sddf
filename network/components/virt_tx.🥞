/*
 * Copyright 2025, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */

#define DRV_QUEUE_BASE           10
#define CLI_QUEUE_BASE           30
#define CLI_DATA_IO_BASE         100
#define CLI_CONN_ID_BASE         150
#define NUM_CLIENTS              2

#define NET_BUFFER_SIZE          2048
#define NET_BUFFER_SHIFT         11
#define NET_BUFFER_MASK          2047

var g_driver_id = 0;

var g_drv_free_queue = 0;
var g_drv_active_queue = 0;
var g_drv_capacity = 0;

var g_cli0_free_queue = 0;
var g_cli0_active_queue = 0;
var g_cli0_capacity = 0;
var g_cli0_data_vaddr = 0;
var g_cli0_data_io = 0;
var g_cli0_conn_id = 0;

var g_cli1_free_queue = 0;
var g_cli1_active_queue = 0;
var g_cli1_capacity = 0;
var g_cli1_data_vaddr = 0;
var g_cli1_data_io = 0;
var g_cli1_conn_id = 0;

var g_notify_cli0 = 0;
var g_notify_cli1 = 0;

fun load_globals() {
    g_driver_id = pnk_mem(0);

    g_drv_free_queue = pnk_mem(DRV_QUEUE_BASE);
    g_drv_active_queue = pnk_mem(DRV_QUEUE_BASE + 1);
    g_drv_capacity = pnk_mem(DRV_QUEUE_BASE + 2);

    g_cli0_free_queue = pnk_mem(CLI_QUEUE_BASE);
    g_cli0_active_queue = pnk_mem(CLI_QUEUE_BASE + 1);
    g_cli0_capacity = pnk_mem(CLI_QUEUE_BASE + 2);
    g_cli0_data_vaddr = pnk_mem(CLI_QUEUE_BASE + 3);
    g_cli0_data_io = pnk_mem(CLI_DATA_IO_BASE);
    g_cli0_conn_id = pnk_mem(CLI_CONN_ID_BASE);

    g_cli1_free_queue = pnk_mem(CLI_QUEUE_BASE + 4);
    g_cli1_active_queue = pnk_mem(CLI_QUEUE_BASE + 5);
    g_cli1_capacity = pnk_mem(CLI_QUEUE_BASE + 6);
    g_cli1_data_vaddr = pnk_mem(CLI_QUEUE_BASE + 7);
    g_cli1_data_io = pnk_mem(CLI_DATA_IO_BASE + 1);
    g_cli1_conn_id = pnk_mem(CLI_CONN_ID_BASE + 1);

    return 0;
}

inline fun {1, 1} extract_offset(1 phys_addr) {
    var cli0_max = g_cli0_data_io + (g_cli0_capacity << NET_BUFFER_SHIFT);
    if (phys_addr >= g_cli0_data_io && phys_addr < cli0_max) {
        var offset = phys_addr - g_cli0_data_io;
        return <0, offset>;
    }

    var cli1_max = g_cli1_data_io + (g_cli1_capacity << NET_BUFFER_SHIFT);
    if (phys_addr >= g_cli1_data_io && phys_addr < cli1_max) {
        var offset = phys_addr - g_cli1_data_io;
        return <1, offset>;
    }

    return <-1, 0>;
}

fun tx_provide_client(1 cli_active, 1 cli_free, 1 cli_cap, 1 cli_data_vaddr, 1 cli_data_io) {
    var enqueued = 0;
    var reprocess = 1;

    var drv_active = g_drv_active_queue;
    var drv_cap = g_drv_capacity;

    while (reprocess) {
        var 1 cli_empty = net_queue_empty(cli_active, cli_cap);

        while (cli_empty == 0) {
            var {1,1} buffer = net_dequeue(cli_active, cli_cap);
            var io_offset = buffer.0;
            var len = buffer.1;

            var aligned = (io_offset & NET_BUFFER_MASK) == 0;
            var in_bounds = io_offset < (cli_cap << NET_BUFFER_SHIFT);

            if (aligned && in_bounds) {
                var buffer_vaddr = cli_data_vaddr + io_offset;
                cache_clean(buffer_vaddr, buffer_vaddr + len)

                var phys_addr = io_offset + cli_data_io;
                net_enqueue(drv_active, phys_addr, len, drv_cap);
                enqueued = 1;
            } else {
                net_enqueue(cli_free, io_offset, len, cli_cap);
            }

            cli_empty = net_queue_empty(cli_active, cli_cap);
        }

        net_request_signal(cli_active, cli_cap);
        reprocess = 0;

        cli_empty = net_queue_empty(cli_active, cli_cap);
        if (cli_empty == 0) {
            net_cancel_signal(cli_active);
            reprocess = 1;
        }
    }

    return enqueued;
}

fun tx_provide() {
    var enqueued = 0;

    var e0 = tx_provide_client(g_cli0_active_queue, g_cli0_free_queue,
                                g_cli0_capacity, g_cli0_data_vaddr, g_cli0_data_io);
    if (e0) { enqueued = 1; }

    var e1 = tx_provide_client(g_cli1_active_queue, g_cli1_free_queue,
                                g_cli1_capacity, g_cli1_data_vaddr, g_cli1_data_io);
    if (e1) { enqueued = 1; }

    if (enqueued) {
        var 1 signal_required = net_require_signal(g_drv_active_queue, g_drv_capacity);
        if (signal_required) {
            net_cancel_signal(g_drv_active_queue);
            sddf_deferred_notify(g_driver_id)
        }
    }

    return 0;
}

fun tx_return() {
    var reprocess = 1;

    g_notify_cli0 = 0;
    g_notify_cli1 = 0;

    var drv_free = g_drv_free_queue;
    var drv_cap = g_drv_capacity;

    while (reprocess) {
        var 1 drv_empty = net_queue_empty(drv_free, drv_cap);

        while (drv_empty == 0) {
            var {1,1} drv_buffer = net_dequeue(drv_free, drv_cap);
            var phys_addr = drv_buffer.0;
            var len = drv_buffer.1;

            var {1,1} extract_result = extract_offset(phys_addr);
            var client = extract_result.0;
            var offset = extract_result.1;

            if (client == 0) {
                net_enqueue(g_cli0_free_queue, offset, len, g_cli0_capacity);
                g_notify_cli0 = 1;
            } else {
                if (client == 1) {
                    net_enqueue(g_cli1_free_queue, offset, len, g_cli1_capacity);
                    g_notify_cli1 = 1;
                }
            }

            drv_empty = net_queue_empty(drv_free, drv_cap);
        }

        net_request_signal(drv_free, drv_cap);
        reprocess = 0;

        drv_empty = net_queue_empty(drv_free, drv_cap);
        if (drv_empty == 0) {
            net_cancel_signal(drv_free);
            reprocess = 1;
        }
    }

    if (g_notify_cli0) {
        var 1 signal_required = net_require_signal(g_cli0_free_queue, g_cli0_capacity);
        if (signal_required) {
            net_cancel_signal(g_cli0_free_queue);
            sddf_notify(g_cli0_conn_id)
        }
    }

    if (g_notify_cli1) {
        var 1 signal_required = net_require_signal(g_cli1_free_queue, g_cli1_capacity);
        if (signal_required) {
            net_cancel_signal(g_cli1_free_queue);
            sddf_notify(g_cli1_conn_id)
        }
    }

    return 0;
}

export fun notified(1 ch) {
    tx_return();
    tx_provide();

    return 0;
}

export fun init_pnk() {
    load_globals();
    return 0;
}
