/*
 * Copyright 2025, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */

#define DRV_QUEUE_BASE           10
#define CLI_QUEUE_BASE           30
#define CLI_MAC_ADDR_BASE        100
#define DATA_IO_ADDR             200
#define DATA_REGION_VADDR        201
#define BUFFER_REFS_BASE         210
#define CLI_CONN_ID_BASE         1210
#define RET_SLOT                 1949
#define NUM_CLIENTS              2

#define BROADCAST_ID             -2

#define NET_BUFFER_SIZE          2048
#define NET_BUFFER_SHIFT         11
#define NET_BUFFER_MASK          2047

var g_driver_id = 0;
var g_data_io_addr = 0;
var g_data_region_vaddr = 0;

var g_drv_free_queue = 0;
var g_drv_active_queue = 0;
var g_drv_capacity = 0;

var g_cli0_free_queue = 0;
var g_cli0_active_queue = 0;
var g_cli0_capacity = 0;
var g_cli0_conn_id = 0;

var g_cli1_free_queue = 0;
var g_cli1_active_queue = 0;
var g_cli1_capacity = 0;
var g_cli1_conn_id = 0;

var g_notify_drv = 0;
var g_notify_cli0 = 0;
var g_notify_cli1 = 0;

fun load_globals() {
    g_driver_id = pnk_mem(0);
    g_data_io_addr = pnk_mem(DATA_IO_ADDR);
    g_data_region_vaddr = pnk_mem(DATA_REGION_VADDR);

    g_drv_free_queue = pnk_mem(DRV_QUEUE_BASE);
    g_drv_active_queue = pnk_mem(DRV_QUEUE_BASE + 1);
    g_drv_capacity = pnk_mem(DRV_QUEUE_BASE + 2);

    g_cli0_free_queue = pnk_mem(CLI_QUEUE_BASE);
    g_cli0_active_queue = pnk_mem(CLI_QUEUE_BASE + 1);
    g_cli0_capacity = pnk_mem(CLI_QUEUE_BASE + 2);
    g_cli0_conn_id = pnk_mem(CLI_CONN_ID_BASE);

    g_cli1_free_queue = pnk_mem(CLI_QUEUE_BASE + 4);
    g_cli1_active_queue = pnk_mem(CLI_QUEUE_BASE + 5);
    g_cli1_capacity = pnk_mem(CLI_QUEUE_BASE + 6);
    g_cli1_conn_id = pnk_mem(CLI_CONN_ID_BASE + 1);

    return 0;
}

inline fun get_mac_addr_match(1 buffer_vaddr) {
    @get_mac_addr_match(buffer_vaddr, 0, 0, 0);
    return pnk_mem(RET_SLOT);
}

fun rx_return() {
    var reprocess = 1;

    g_notify_cli0 = 0;
    g_notify_cli1 = 0;

    var drv_active = g_drv_active_queue;
    var drv_cap = g_drv_capacity;
    var io_addr = g_data_io_addr;
    var region_vaddr = g_data_region_vaddr;
    var drv_free = g_drv_free_queue;

    while (reprocess) {
        var 1 drv_empty = net_queue_empty(drv_active, drv_cap);

        while (drv_empty == 0) {
            var {1,1} buffer = net_dequeue(drv_active, drv_cap);
            var io_offset = buffer.0;
            var len = buffer.1;

            io_offset = io_offset - io_addr;
            var buffer_vaddr = io_offset + region_vaddr;

            cache_clean_and_invalidate(buffer_vaddr, buffer_vaddr + len)

            var 1 client = get_mac_addr_match(buffer_vaddr);

            if (client == BROADCAST_ID) {
                var ref_index = io_offset >> NET_BUFFER_SHIFT;
                var ref_addr = pnk_mem_ptr(BUFFER_REFS_BASE + ref_index);
                !st32 ref_addr, NUM_CLIENTS;

                net_enqueue(g_cli0_active_queue, io_offset, len, g_cli0_capacity);
                g_notify_cli0 = 1;

                net_enqueue(g_cli1_active_queue, io_offset, len, g_cli1_capacity);
                g_notify_cli1 = 1;
            } else {
                if (client == 0) {
                    var ref_index = io_offset >> NET_BUFFER_SHIFT;
                    var ref_addr = pnk_mem_ptr(BUFFER_REFS_BASE + ref_index);
                    !st32 ref_addr, 1;

                    net_enqueue(g_cli0_active_queue, io_offset, len, g_cli0_capacity);
                    g_notify_cli0 = 1;
                } else {
                    if (client == 1) {
                        var ref_index = io_offset >> NET_BUFFER_SHIFT;
                        var ref_addr = pnk_mem_ptr(BUFFER_REFS_BASE + ref_index);
                        !st32 ref_addr, 1;

                        net_enqueue(g_cli1_active_queue, io_offset, len, g_cli1_capacity);
                        g_notify_cli1 = 1;
                    } else {
                        io_offset = io_offset + io_addr;
                        net_enqueue(drv_free, io_offset, len, drv_cap);
                        g_notify_drv = 1;
                    }
                }
            }

            drv_empty = net_queue_empty(drv_active, drv_cap);
        }

        net_request_signal(drv_active, drv_cap);
        reprocess = 0;

        drv_empty = net_queue_empty(drv_active, drv_cap);
        if (drv_empty == 0) {
            net_cancel_signal(drv_active);
            reprocess = 1;
        }
    }

    if (g_notify_cli0) {
        var 1 signal_required = net_require_signal(g_cli0_active_queue, g_cli0_capacity);
        if (signal_required) {
            net_cancel_signal(g_cli0_active_queue);
            sddf_notify(g_cli0_conn_id)
        }
    }

    if (g_notify_cli1) {
        var 1 signal_required = net_require_signal(g_cli1_active_queue, g_cli1_capacity);
        if (signal_required) {
            net_cancel_signal(g_cli1_active_queue);
            sddf_notify(g_cli1_conn_id)
        }
    }

    return 0;
}

fun rx_provide_client(1 cli_free_queue, 1 cli_capacity) {
    var reprocess = 1;

    var io_addr = g_data_io_addr;
    var drv_free = g_drv_free_queue;
    var drv_cap = g_drv_capacity;

    while (reprocess) {
        var 1 cli_empty = net_queue_empty(cli_free_queue, cli_capacity);

        while (cli_empty == 0) {
            var {1,1} buffer = net_dequeue(cli_free_queue, cli_capacity);
            var io_offset = buffer.0;
            var len = buffer.1;

            var aligned = (io_offset & NET_BUFFER_MASK) == 0;
            var in_bounds = io_offset < (cli_capacity << NET_BUFFER_SHIFT);

            if (aligned && in_bounds) {
                var ref_index = io_offset >> NET_BUFFER_SHIFT;
                var ref_count = pnk_mem(BUFFER_REFS_BASE + ref_index);

                if (ref_count > 0) {
                    ref_count = ref_count - 1;
                    var ref_addr = pnk_mem_ptr(BUFFER_REFS_BASE + ref_index);
                    !st32 ref_addr, ref_count;

                    if (ref_count == 0) {
                        io_offset = io_offset + io_addr;
                        net_enqueue(drv_free, io_offset, len, drv_cap);
                        g_notify_drv = 1;
                    }
                }
            }

            cli_empty = net_queue_empty(cli_free_queue, cli_capacity);
        }

        net_request_signal(cli_free_queue, cli_capacity);
        reprocess = 0;

        cli_empty = net_queue_empty(cli_free_queue, cli_capacity);
        if (cli_empty == 0) {
            net_cancel_signal(cli_free_queue);
            reprocess = 1;
        }
    }

    return 0;
}

fun rx_provide() {
    rx_provide_client(g_cli0_free_queue, g_cli0_capacity);
    rx_provide_client(g_cli1_free_queue, g_cli1_capacity);

    if (g_notify_drv) {
        var 1 signal_required = net_require_signal(g_drv_free_queue, g_drv_capacity);

        if (signal_required) {
            net_cancel_signal(g_drv_free_queue);
            sddf_deferred_notify(g_driver_id)
            g_notify_drv = 0;
        }
    }

    return 0;
}

export fun notified(1 ch) {
    rx_return();
    rx_provide();

    return 0;
}

export fun init_pnk() {
    load_globals();
    return 0;
}
