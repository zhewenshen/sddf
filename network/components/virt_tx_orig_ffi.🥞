/*
 * Copyright 2025, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */

#define CONFIG_DRIVER_ID         pnk_mem(0)
#define DRV_QUEUE_BASE           10
#define CLI_QUEUE_BASE           30
#define CLI_DATA_IO_BASE         100
#define CLI_CONN_ID_BASE         150
#define NUM_CLIENTS              200
#define NOTIFY_CLIENTS_BASE      210
#define RET_SLOT                 250

// Buffer constants
#define NET_BUFFER_SIZE          2048
#define NET_BUFFER_SHIFT         11
#define NET_BUFFER_MASK          2047

// FFI version - calls C function and reads results from RET_SLOT, RET_SLOT+1
fun extract_offset(1 phys_addr) {
    @extract_offset(phys_addr, 0, 0, 0);
    var client = pnk_mem(RET_SLOT);
    var offset = pnk_mem(RET_SLOT + 1);
    return <client, offset>;
}

fun tx_provide() {
    var enqueued = 0;
    var num_clients = pnk_mem(NUM_CLIENTS);
    var client = 0;

    // Cache driver queue info
    var drv_active_queue = pnk_mem(DRV_QUEUE_BASE + 1);
    var drv_capacity = pnk_mem(DRV_QUEUE_BASE + 2);

    while (client < num_clients) {
        var reprocess = 1;

        var cli_queue_base = CLI_QUEUE_BASE + client * 4;
        var cli_active_queue = pnk_mem(cli_queue_base + 1);
        var cli_capacity = pnk_mem(cli_queue_base + 2);
        var cli_free_queue = pnk_mem(cli_queue_base);
        var cli_data_vaddr = pnk_mem(cli_queue_base + 3);
        var cli_data_io = pnk_mem(CLI_DATA_IO_BASE + client);

        while (reprocess) {
            var 1 cli_empty = net_queue_empty(cli_active_queue, cli_capacity);

            while (cli_empty == 0) {
                var {1,1} buffer = net_dequeue(cli_active_queue, cli_capacity);
                var io_offset = buffer.0;
                var len = buffer.1;

                var aligned = (io_offset & NET_BUFFER_MASK) == 0;
                var in_bounds = io_offset < (cli_capacity << NET_BUFFER_SHIFT);

                if (aligned && in_bounds) {
                    var buffer_vaddr = cli_data_vaddr + io_offset;
                    cache_clean(buffer_vaddr, buffer_vaddr + len)

                    var phys_addr = io_offset + cli_data_io;
                    net_enqueue(drv_active_queue, phys_addr, len, drv_capacity);
                    enqueued = 1;
                } else {
                    net_enqueue(cli_free_queue, io_offset, len, cli_capacity);
                }

                cli_empty = net_queue_empty(cli_active_queue, cli_capacity);
            }

            net_request_signal(cli_active_queue, cli_capacity);
            reprocess = 0;

            cli_empty = net_queue_empty(cli_active_queue, cli_capacity);
            if (cli_empty == 0) {
                net_cancel_signal(cli_active_queue);
                reprocess = 1;
            }
        }

        client = client + 1;
    }

    if (enqueued) {
        var 1 signal_required = net_require_signal(drv_active_queue, drv_capacity);

        if (signal_required) {
            net_cancel_signal(drv_active_queue);
            sddf_deferred_notify(CONFIG_DRIVER_ID)
        }
    }

    return 0;
}

fun tx_return() {
    var reprocess = 1;
    var num_clients = pnk_mem(NUM_CLIENTS);

    var i = 0;
    while (i < num_clients) {
        var notify_addr = pnk_mem_ptr(NOTIFY_CLIENTS_BASE + i);
        !st32 notify_addr, 0;
        i = i + 1;
    }

    // Cache driver queue info
    var drv_free_queue = pnk_mem(DRV_QUEUE_BASE);
    var drv_capacity = pnk_mem(DRV_QUEUE_BASE + 2);

    while (reprocess) {
        var 1 drv_empty = net_queue_empty(drv_free_queue, drv_capacity);

        while (drv_empty == 0) {
            var {1,1} drv_buffer = net_dequeue(drv_free_queue, drv_capacity);
            var phys_addr = drv_buffer.0;
            var len = drv_buffer.1;

            var {1,1} extract_result = extract_offset(phys_addr);
            var client = extract_result.0;
            var offset = extract_result.1;

            if (client >= 0) {
                var cli_queue_base = CLI_QUEUE_BASE + client * 4;
                var cli_free_queue = pnk_mem(cli_queue_base);
                var cli_capacity = pnk_mem(cli_queue_base + 2);

                net_enqueue(cli_free_queue, offset, len, cli_capacity);

                var notify_addr = pnk_mem_ptr(NOTIFY_CLIENTS_BASE + client);
                !st32 notify_addr, 1;
            }

            drv_empty = net_queue_empty(drv_free_queue, drv_capacity);
        }

        net_request_signal(drv_free_queue, drv_capacity);
        reprocess = 0;

        drv_empty = net_queue_empty(drv_free_queue, drv_capacity);
        if (drv_empty == 0) {
            net_cancel_signal(drv_free_queue);
            reprocess = 1;
        }
    }

    var client = 0;
    while (client < num_clients) {
        var notify_flag = pnk_mem(NOTIFY_CLIENTS_BASE + client);

        if (notify_flag) {
            var cli_queue_base = CLI_QUEUE_BASE + client * 4;
            var cli_free_queue = pnk_mem(cli_queue_base);
            var cli_capacity = pnk_mem(cli_queue_base + 2);
            var 1 signal_required = net_require_signal(cli_free_queue, cli_capacity);

            if (signal_required) {
                net_cancel_signal(cli_free_queue);
                var cli_conn_id = pnk_mem(CLI_CONN_ID_BASE + client);
                sddf_notify(cli_conn_id)
            }
        }

        client = client + 1;
    }

    return 0;
}

export fun notified(1 ch) {
    tx_return();
    tx_provide();

    return 0;
}
