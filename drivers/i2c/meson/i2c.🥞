var 1 g_curr_data = 0;
var 1 g_curr_request_len = 0;
var 1 g_curr_response_len = 0;
var 1 g_remaining = 0;
var 1 g_notified = 0;
var 1 g_rw_remaining = 0;
var 1 g_data_direction = 0;
var 1 g_addr = 0;

var 1 g_request_queue_ptr = 0;
var 1 g_response_queue_ptr = 0;
var 1 g_data_region_base = 0;

var 1 g_ctl_reg_addr = 0;
var 1 g_addr_reg_addr = 0;
var 1 g_tk_list0_addr = 0;
var 1 g_tk_list1_addr = 0;
var 1 g_wdata0_addr = 0;
var 1 g_wdata1_addr = 0;
var 1 g_rdata0_addr = 0;
var 1 g_rdata1_addr = 0;

var 1 virt = pnk_mem(3);
var 1 irq0 = pnk_mem(1);
var 1 irq1 = pnk_mem(2);

#define I2C_CURR_DATA           g_curr_data
#define I2C_CURR_REQUEST_LEN    g_curr_request_len
#define I2C_CURR_RESPONSE_LEN   g_curr_response_len
#define I2C_REMAINING           g_remaining
#define I2C_NOTIFIED            g_notified
#define I2C_RW_REMAINING        g_rw_remaining
#define I2C_DATA_DIRECTION      g_data_direction
#define I2C_ADDR                g_addr

#define RESPONSE_ERR            0
#define RESPONSE_ERR_TOKEN      1
#define RESPONSE_DATA_OFFSET    2
#define I2C_ERR_OK              0
#define I2C_ERR_TIMEOUT         1
#define I2C_ERR_NACK            2
#define I2C_ERR_NOREAD          3
#define I2C_TOKEN_ADDR_READ     3

#define MESON_I2C_TOKEN_END         0
#define MESON_I2C_TOKEN_START       1
#define MESON_I2C_TOKEN_ADDR_WRITE  2
#define MESON_I2C_TOKEN_ADDR_READ   3
#define MESON_I2C_TOKEN_DATA        4
#define MESON_I2C_TOKEN_DATA_END    5
#define MESON_I2C_TOKEN_STOP        6

#define DATA_DIRECTION_WRITE    0
#define DATA_DIRECTION_READ     1

#define I2C_MAX_DATA_SIZE       128
#define MESON_I2C_MAX_BUS_ADDRESS 127

#define NUM_QUEUE_ENTRIES       32

fun init_globals() {
    var handle_ptr = pnk_mem_ptr(4);
    !ldw g_request_queue_ptr, handle_ptr;
    var response_ptr_addr = handle_ptr + 8;
    !ldw g_response_queue_ptr, response_ptr_addr;
    g_data_region_base = pnk_mem(21);

    var base_reg = pnk_mem(0);
    g_ctl_reg_addr = base_reg + 0;
    g_addr_reg_addr = base_reg + 4;
    g_tk_list0_addr = base_reg + 8;
    g_tk_list1_addr = base_reg + 12;
    g_wdata0_addr = base_reg + 16;
    g_wdata1_addr = base_reg + 20;
    g_rdata0_addr = base_reg + 24;
    g_rdata1_addr = base_reg + 28;

    return 0;
}

fun get_queue_head(1 queue_ptr) {
    var head_addr = queue_ptr + 4;
    var head = 0;
    !ld32 head, head_addr;
    return head;
}

fun set_queue_head(1 queue_ptr, 1 head) {
    var head_addr = queue_ptr + 4;
    !st32 head_addr, head;
    return 0;
}

fun get_queue_tail(1 queue_ptr) {
    var tail_addr = queue_ptr + 0;
    var tail = 0;
    !ld32 tail, tail_addr;
    return tail;
}

fun set_queue_tail(1 queue_ptr, 1 tail) {
    var tail_addr = queue_ptr + 0;
    !st32 tail_addr, tail;
    return 0;
}

fun get_entry_offset(1 queue_ptr, 1 index) {
    var entry_base = queue_ptr + 8 + (index * 24);
    var offset = 0;
    !ldw offset, entry_base;
    return offset;
}

fun set_entry_offset(1 queue_ptr, 1 index, 1 offset) {
    var entry_base = queue_ptr + 8 + (index * 24);
    !stw entry_base, offset;
    return 0;
}

fun get_entry_len(1 queue_ptr, 1 index) {
    var entry_base = queue_ptr + 8 + (index * 24) + 8;
    var len = 0;
    !ld32 len, entry_base;
    return len;
}

fun set_entry_len(1 queue_ptr, 1 index, 1 len) {
    var entry_base = queue_ptr + 8 + (index * 24) + 8;
    !st32 entry_base, len;
    return 0;
}

fun get_entry_bus_address(1 queue_ptr, 1 index) {
    var entry_base = queue_ptr + 8 + (index * 24) + 16;
    var bus_address = 0;
    !ldw bus_address, entry_base;
    return bus_address;
}

fun set_entry_bus_address(1 queue_ptr, 1 index, 1 bus_address) {
    var entry_base = queue_ptr + 8 + (index * 24) + 16;
    !stw entry_base, bus_address;
    return 0;
}

fun i2c_queue_empty_pnk(1 queue_ptr) {
    var 1 head = get_queue_head(queue_ptr);
    var 1 tail = get_queue_tail(queue_ptr);
    var diff = tail - head;
    if (diff == 0) {
        return 1;
    }
    return 0;
}

fun i2c_queue_full_pnk(1 queue_ptr) {
    var 1 head = get_queue_head(queue_ptr);
    var 1 tail = get_queue_tail(queue_ptr);
    var diff = tail - head + 1;
    if (diff == NUM_QUEUE_ENTRIES) {
        return 1;
    }
    return 0;
}

fun i2c_enqueue_pnk(1 queue_ptr, 1 bus_address, 1 offset, 1 len) {
    var 1 is_full = i2c_queue_full_pnk(queue_ptr);
    if (is_full) {
        return 1;
    }

    var 1 tail = get_queue_tail(queue_ptr);
    var index = tail & (NUM_QUEUE_ENTRIES - 1);

    set_entry_bus_address(queue_ptr, index, bus_address);
    set_entry_offset(queue_ptr, index, offset);
    set_entry_len(queue_ptr, index, len);

    THREAD_MEMORY_RELEASE()
    var new_tail = tail + 1;
    set_queue_tail(queue_ptr, new_tail);

    return 0;
}

fun i2c_dequeue_pnk(1 queue_ptr) {
    var 1 is_empty = i2c_queue_empty_pnk(queue_ptr);
    if (is_empty) {
        return <1, 0, 0, 0>;
    }

    var 1 head = get_queue_head(queue_ptr);
    var index = head & (NUM_QUEUE_ENTRIES - 1);

    var 1 bus_address = get_entry_bus_address(queue_ptr, index);
    var 1 offset = get_entry_offset(queue_ptr, index);
    var 1 len = get_entry_len(queue_ptr, index);

    THREAD_MEMORY_RELEASE()
    var new_head = head + 1;
    set_queue_head(queue_ptr, new_head);

    return <0, bus_address, offset, len>;
}


fun get_i2c_error() {
    var ctl = 0;
    !ld32 ctl, g_ctl_reg_addr;

    var err = ctl & (1 << 3);
    var bytes_read = (ctl >> 8) & 15;
    var curr_token = (ctl >> 4) & 15;

    return <err, bytes_read, curr_token>;
}

fun i2c_halt() {
    var ctl = 0;
    !ld32 ctl, g_ctl_reg_addr;
    ctl = ctl & 4294967294;
    !st32 g_ctl_reg_addr, ctl;
    return 0;
}

fun handle_response() {
    var 3 error_info = get_i2c_error();
    var write_error = error_info.0;
    var bytes_read = error_info.1;
    var curr_token = error_info.2;


    var return_buffer = I2C_CURR_DATA;

    if (write_error) {
        var err_addr = return_buffer + RESPONSE_ERR;
        var token_addr = return_buffer + RESPONSE_ERR_TOKEN;
        if (curr_token == I2C_TOKEN_ADDR_READ) {
            !st8 err_addr, I2C_ERR_NOREAD;
        } else {
            !st8 err_addr, I2C_ERR_NACK;
        }
        !st8 token_addr, curr_token;
    } else {
        var bytes_copied = 0;
        while (bytes_copied < bytes_read) {
            var curr_resp_len = I2C_CURR_RESPONSE_LEN;
            var index = RESPONSE_DATA_OFFSET + curr_resp_len;

            var value = 0;

            if (bytes_copied < 4) {
                var byte_addr = g_rdata0_addr + bytes_copied;
                !ld8 value, byte_addr;
            } else {
                if (bytes_copied < 8) {
                    var byte_addr = g_rdata1_addr + (bytes_copied - 4);
                    !ld8 value, byte_addr;
                }
            }


            var data_addr = return_buffer + index;
            !st8 data_addr, value;

            var new_resp_len = g_curr_response_len + 1;
            g_curr_response_len = new_resp_len;

            bytes_copied = bytes_copied + 1;
        }

        var err_addr = return_buffer + RESPONSE_ERR;
        var token_addr = return_buffer + RESPONSE_ERR_TOKEN;
        !st8 err_addr, I2C_ERR_OK;
        !st8 token_addr, 0;
    }

    var remaining = I2C_REMAINING;
    if (write_error || remaining == 0) {
        var resp_queue_ptr = g_response_queue_ptr;
        var bus_address = g_addr;
        var curr_data = g_curr_data;
        var offset = curr_data - g_data_region_base;
        var response_len = I2C_CURR_RESPONSE_LEN + RESPONSE_DATA_OFFSET;
        i2c_enqueue_pnk(resp_queue_ptr, bus_address, offset, response_len);

        g_curr_response_len = 0;
        g_curr_data = 0;
        g_curr_request_len = 0;
        g_remaining = 0;
        g_addr = 0;

        microkit_notify(virt)
        i2c_halt();
    }

    var remaining_check = I2C_REMAINING;
    var notified_check = I2C_NOTIFIED;
    if (remaining_check > 0) {
        i2c_load_tokens();
    } else {
        if (notified_check > 0) {
            handle_request();
        }
    }

    return 0;
}

fun token_shift_left(1 token, 1 tk_offset) {
    if (tk_offset == 0) { return token << 0; }
    if (tk_offset == 1) { return token << 4; }
    if (tk_offset == 2) { return token << 8; }
    if (tk_offset == 3) { return token << 12; }
    if (tk_offset == 4) { return token << 16; }
    if (tk_offset == 5) { return token << 20; }
    if (tk_offset == 6) { return token << 24; }
    if (tk_offset == 7) { return token << 28; }
    return 0;
}

fun data_shift_left(1 data, 1 wdata_offset) {
    if (wdata_offset == 0) { return data << 0; }
    if (wdata_offset == 1) { return data << 8; }
    if (wdata_offset == 2) { return data << 16; }
    if (wdata_offset == 3) { return data << 24; }
    return 0;
}

fun convert_token(1 token) {
    if (token == 0) { return MESON_I2C_TOKEN_END; }
    if (token == 1) { return MESON_I2C_TOKEN_START; }
    if (token == 2) {
        g_data_direction = DATA_DIRECTION_WRITE;
        return MESON_I2C_TOKEN_ADDR_WRITE;
    }
    if (token == 3) {
        g_data_direction = DATA_DIRECTION_READ;
        return MESON_I2C_TOKEN_ADDR_READ;
    }
    if (token == 4) { return MESON_I2C_TOKEN_STOP; }
    return MESON_I2C_TOKEN_END;
}

fun i2c_load_tokens() {
    var tokens = g_curr_data;
    var remaining = g_remaining;
    var curr_request_len = g_curr_request_len;

    var addr_reg = 0;
    !ld32 addr_reg, g_addr_reg_addr;
    addr_reg = addr_reg & 4294967040;
    var device_addr = (g_addr & 127) * 2;
    addr_reg = addr_reg | device_addr;
    !st32 g_addr_reg_addr, addr_reg;

    !st32 g_tk_list0_addr, 0;
    !st32 g_tk_list1_addr, 0;
    !st32 g_wdata0_addr, 0;
    !st32 g_wdata1_addr, 0;

    var tk_offset = 0;
    var wdata_offset = 0;
    var rdata_offset = 0;
    var request_data_offset = curr_request_len - remaining;

    while (tk_offset < 16 && wdata_offset < 8 && rdata_offset < 8 && request_data_offset < curr_request_len) {
        var meson_token = 0;
        var data = 0;
        var rw_remaining = g_rw_remaining;

        if (rw_remaining == 0) {
            var token_addr = tokens + request_data_offset;
            var token = 0;
            !ld8 token, token_addr;
            var 1 converted_token = convert_token(token);
            meson_token = converted_token;

            if (meson_token == MESON_I2C_TOKEN_ADDR_WRITE || meson_token == MESON_I2C_TOKEN_ADDR_READ) {
                var len_addr = tokens + request_data_offset + 1;
                var buff_length = 0;
                !ld8 buff_length, len_addr;

                g_rw_remaining = buff_length;
                if (meson_token == MESON_I2C_TOKEN_ADDR_WRITE) {
                    g_data_direction = DATA_DIRECTION_WRITE;
                } else {
                    g_data_direction = DATA_DIRECTION_READ;
                }

                request_data_offset = request_data_offset + 1;
            }
        } else {
            var data_direction = g_data_direction;
            if (rw_remaining == 1 && data_direction == DATA_DIRECTION_READ) {
                meson_token = MESON_I2C_TOKEN_DATA_END;
            } else {
                meson_token = MESON_I2C_TOKEN_DATA;
            }
            if (data_direction == DATA_DIRECTION_WRITE) {
                var data_addr = tokens + request_data_offset;
                !ld8 data, data_addr;
            }
            var new_rw_remaining = rw_remaining - 1;
            g_rw_remaining = new_rw_remaining;
        }

        if (tk_offset < 8) {
            var tk_list0 = 0;
            !ld32 tk_list0, g_tk_list0_addr;
            var 1 shifted_token = token_shift_left(meson_token, tk_offset);
            tk_list0 = tk_list0 | shifted_token;
            !st32 g_tk_list0_addr, tk_list0;
        } else {
            var tk_list1 = 0;
            !ld32 tk_list1, g_tk_list1_addr;
            var offset_mod8 = tk_offset - 8;
            var 1 shifted_token = token_shift_left(meson_token, offset_mod8);
            tk_list1 = tk_list1 | shifted_token;
            !st32 g_tk_list1_addr, tk_list1;
        }
        tk_offset = tk_offset + 1;

        var data_direction_check = g_data_direction;
        if (meson_token == MESON_I2C_TOKEN_DATA && data_direction_check == DATA_DIRECTION_WRITE) {
            if (wdata_offset < 4) {
                var wdata0 = 0;
                !ld32 wdata0, g_wdata0_addr;
                var 1 shifted_data = data_shift_left(data, wdata_offset);
                wdata0 = wdata0 | shifted_data;
                !st32 g_wdata0_addr, wdata0;
            } else {
                var wdata1 = 0;
                !ld32 wdata1, g_wdata1_addr;
                var offset_minus4 = wdata_offset - 4;
                var 1 shifted_data = data_shift_left(data, offset_minus4);
                wdata1 = wdata1 | shifted_data;
                !st32 g_wdata1_addr, wdata1;
            }
            wdata_offset = wdata_offset + 1;
        }

        if ((meson_token == MESON_I2C_TOKEN_DATA || meson_token == MESON_I2C_TOKEN_DATA_END)
            && data_direction_check == DATA_DIRECTION_READ) {
            rdata_offset = rdata_offset + 1;
        }

        request_data_offset = request_data_offset + 1;
    }

    var new_remaining = curr_request_len - request_data_offset;
    g_remaining = new_remaining;

    i2c_start();

    return 0;
}

fun i2c_start() {
    var ctl = 0;
    !ld32 ctl, g_ctl_reg_addr;
    ctl = ctl & 4294967294;
    !st32 g_ctl_reg_addr, ctl;
    ctl = ctl | 1;
    !st32 g_ctl_reg_addr, ctl;
    return 0;
}

fun handle_request() {
    var 1 queue_empty = i2c_queue_empty_pnk(g_request_queue_ptr);

    if (queue_empty == 0) {
        var curr_data = I2C_CURR_DATA;
        if (curr_data != 0) {
            g_notified = 1;
            return 0;
        }

        var 4 dequeue_result = i2c_dequeue_pnk(g_request_queue_ptr);
        var err = dequeue_result.0;
        var bus_address = dequeue_result.1;
        var offset = dequeue_result.2;
        var size = dequeue_result.3;

        if (err != 0) {
            return 0;
        }

        if (size > I2C_MAX_DATA_SIZE) {
            return 0;
        }

        if (bus_address > MESON_I2C_MAX_BUS_ADDRESS) {
            return 0;
        }

        var curr_data_addr = g_data_region_base + offset;
        g_curr_data = curr_data_addr;
        g_addr = bus_address;
        g_curr_request_len = size;
        g_remaining = size;
        g_notified = 0;

        i2c_load_tokens();
    } else {
        g_notified = 0;
    }

    return 0;
}

fun main() {
    init_globals();
    return 0;
}


export fun notified(1 ch) {
    if (ch == virt) {
        handle_request();
    } else {
        if (ch == irq0) {
            handle_response();
            microkit_deferred_irq_ack(ch)
        } else {
            if (ch == irq1) {
                microkit_deferred_irq_ack(ch)
            }
        }
    }
    return 0;
}
