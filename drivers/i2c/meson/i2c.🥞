/* Memory access helpers */
#define IRQ_CH_0                pnk_mem(1)
#define IRQ_CH_1                pnk_mem(2)
#define VIRT_CH                 pnk_mem(3)

/* I2C State structure in pancake memory */
#define I2C_STATE_PTR           pnk_mem_ptr(6)
#define I2C_CURR_DATA           pnk_mem(6)
#define I2C_CURR_REQUEST_LEN    pnk_mem(7)
#define I2C_CURR_RESPONSE_LEN   pnk_mem(8)
#define I2C_REMAINING           pnk_mem(9)
#define I2C_NOTIFIED            pnk_mem(10)
#define I2C_RW_REMAINING        pnk_mem(11)
#define I2C_DATA_DIRECTION      pnk_mem(12)
#define I2C_ADDR                pnk_mem(13)

/* Queue handle in pancake memory */
#define QUEUE_HANDLE_PTR        pnk_mem_ptr(4)

/* Hardware register base */
#define I2C_REG                 pnk_mem(0)

/* Constants */
#define RESPONSE_ERR            0
#define RESPONSE_ERR_TOKEN      1
#define RESPONSE_DATA_OFFSET    2
#define I2C_ERR_OK              0
#define I2C_ERR_TIMEOUT         1
#define I2C_ERR_NACK            2
#define I2C_ERR_NOREAD          3
#define I2C_TOKEN_ADDR_READ     3

/* Meson I2C token constants */
#define MESON_I2C_TOKEN_END         0
#define MESON_I2C_TOKEN_START       1
#define MESON_I2C_TOKEN_ADDR_WRITE  2
#define MESON_I2C_TOKEN_ADDR_READ   3
#define MESON_I2C_TOKEN_DATA        4
#define MESON_I2C_TOKEN_DATA_END    5
#define MESON_I2C_TOKEN_STOP        6

/* Data direction constants */
#define DATA_DIRECTION_WRITE    0
#define DATA_DIRECTION_READ     1

/* Validation constants */
#define I2C_MAX_DATA_SIZE       128
#define MESON_I2C_MAX_BUS_ADDRESS 127

/* Queue constants */
#define NUM_QUEUE_ENTRIES       32


var 1 irq_ch_0 = IRQ_CH_0;
var 1 irq_ch_1 = IRQ_CH_1;
var 1 virt_ch = VIRT_CH;
var 1 i2c_reg = I2C_REG;

/* Queue memory access helpers */
/* Queue structure: tail(4) + head(4) + entries(NUM_QUEUE_ENTRIES * 24) */
/* Each entry: offset(8) + len(4) + bus_address(8) = 24 bytes */
/* Note: Fixed to match queue.h structure layout */

/* Get queue head */
fun get_queue_head(1 queue_ptr) {
    var head_addr = queue_ptr + 4;
    var head = 0;
    !ld32 head, head_addr;
    return head;
}

/* Set queue head */
fun set_queue_head(1 queue_ptr, 1 head) {
    var head_addr = queue_ptr + 4;
    !st32 head_addr, head;
    return 0;
}

/* Get queue tail */
fun get_queue_tail(1 queue_ptr) {
    var tail_addr = queue_ptr + 0;
    var tail = 0;
    !ld32 tail, tail_addr;
    return tail;
}

/* Set queue tail */
fun set_queue_tail(1 queue_ptr, 1 tail) {
    var tail_addr = queue_ptr + 0;
    !st32 tail_addr, tail;
    return 0;
}

/* Get entry offset (8 bytes) */
fun get_entry_offset(1 queue_ptr, 1 index) {
    var entry_base = queue_ptr + 8 + (index * 24);
    var offset = 0;
    !ldw offset, entry_base;
    return offset;
}

/* Set entry offset */
fun set_entry_offset(1 queue_ptr, 1 index, 1 offset) {
    var entry_base = queue_ptr + 8 + (index * 24);
    !stw entry_base, offset;
    return 0;
}

/* Get entry len (4 bytes) */
fun get_entry_len(1 queue_ptr, 1 index) {
    var entry_base = queue_ptr + 8 + (index * 24) + 8;
    var len = 0;
    !ld32 len, entry_base;
    return len;
}

/* Set entry len */
fun set_entry_len(1 queue_ptr, 1 index, 1 len) {
    var entry_base = queue_ptr + 8 + (index * 24) + 8;
    !st32 entry_base, len;
    return 0;
}

/* Get entry bus_address (8 bytes) */
fun get_entry_bus_address(1 queue_ptr, 1 index) {
    var entry_base = queue_ptr + 8 + (index * 24) + 16;
    var bus_address = 0;
    !ldw bus_address, entry_base;
    return bus_address;
}

/* Set entry bus_address */
fun set_entry_bus_address(1 queue_ptr, 1 index, 1 bus_address) {
    var entry_base = queue_ptr + 8 + (index * 24) + 16;
    !stw entry_base, bus_address;
    return 0;
}

/* Check if queue is empty */
fun i2c_queue_empty_pnk(1 queue_ptr) {
    var 1 head = get_queue_head(queue_ptr);
    var 1 tail = get_queue_tail(queue_ptr);
    var diff = tail - head;
    if (diff == 0) {
        return 1; /* empty */
    }
    return 0; /* not empty */
}

/* Check if queue is full */
fun i2c_queue_full_pnk(1 queue_ptr) {
    var 1 head = get_queue_head(queue_ptr);
    var 1 tail = get_queue_tail(queue_ptr);
    var diff = tail - head + 1;
    if (diff == NUM_QUEUE_ENTRIES) {
        return 1; /* full */
    }
    return 0; /* not full */
}

/* Enqueue to queue */
fun i2c_enqueue_pnk(1 queue_ptr, 1 bus_address, 1 offset, 1 len) {
    var 1 is_full = i2c_queue_full_pnk(queue_ptr);
    if (is_full) {
        return 1; /* error - queue full */
    }

    var 1 tail = get_queue_tail(queue_ptr);
    var index = tail & (NUM_QUEUE_ENTRIES - 1); /* tail % NUM_QUEUE_ENTRIES */

    set_entry_bus_address(queue_ptr, index, bus_address);
    set_entry_offset(queue_ptr, index, offset);
    set_entry_len(queue_ptr, index, len);

    THREAD_MEMORY_RELEASE()
    var new_tail = tail + 1;
    set_queue_tail(queue_ptr, new_tail);

    return 0; /* success */
}

/* Dequeue from queue - stores results in pancake memory slots 17-20 */
fun i2c_dequeue_pnk(1 queue_ptr) {
    var 1 is_empty = i2c_queue_empty_pnk(queue_ptr);
    if (is_empty) {
        st pnk_mem_ptr(17), 1; /* error */
        return 1;
    }

    var 1 head = get_queue_head(queue_ptr);
    var index = head & (NUM_QUEUE_ENTRIES - 1); /* head % NUM_QUEUE_ENTRIES */

    var 1 bus_address = get_entry_bus_address(queue_ptr, index);
    var 1 offset = get_entry_offset(queue_ptr, index);
    var 1 len = get_entry_len(queue_ptr, index);

    THREAD_MEMORY_RELEASE()
    var new_head = head + 1;
    set_queue_head(queue_ptr, new_head);

    /* Store results in pancake memory */
    st pnk_mem_ptr(17), 0;           /* error = 0 (success) */
    st pnk_mem_ptr(18), bus_address; /* bus_address */
    st pnk_mem_ptr(19), offset;      /* offset */
    st pnk_mem_ptr(20), len;         /* len */

    return 0; /* success */
}

/* Get queue pointers from handle */
fun get_request_queue_ptr() {
    var handle_ptr = pnk_mem_ptr(4); /* queue_handle is at slot 4 */
    var request_ptr = 0;
    !ldw request_ptr, handle_ptr;   /* request is first field in handle */
    return request_ptr;
}

fun get_response_queue_ptr() {
    var handle_ptr = pnk_mem_ptr(4); /* queue_handle is at slot 4 */
    var response_ptr_addr = handle_ptr + 8; /* response is second field */
    var response_ptr = 0;
    !ldw response_ptr, response_ptr_addr;
    return response_ptr;
}


/* Helper function to get error status from i2c control register */
fun get_i2c_error() {
    var ctl_addr = i2c_reg + 0; /* ctl register offset is 0 */
    var ctl = 0;
    !ld32 ctl, ctl_addr;

    var err = ctl & (1 << 3);           /* bit 3 -> set if error */
    var bytes_read = (ctl >> 8) & 15;   /* bits 8-11 -> number of bytes to read (0xF = 15) */
    var curr_token = (ctl >> 4) & 15;   /* bits 4-7 -> curr token (0xF = 15) */

    return <err, bytes_read, curr_token>;
}

/* Function to halt i2c operation */
fun i2c_halt() {
    var ctl_addr = i2c_reg + 0;
    var ctl = 0;
    !ld32 ctl, ctl_addr;
    ctl = ctl & 4294967294;  /* clear start bit (bit 0) - 0xFFFFFFFE = 4294967294 */
    !st32 ctl_addr, ctl;
    return 0;
}

fun handle_response() {
    /* Get error status using Pancake logic */
    var 3 error_info = get_i2c_error();
    var write_error = error_info.0;
    var bytes_read = error_info.1;
    var curr_token = error_info.2;

    /* Store bytes_read in pancake memory for FFI function */
    st pnk_mem_ptr(23), bytes_read;

    /* Get return buffer pointer */
    var return_buffer = I2C_CURR_DATA;

    /* Handle error checking in Pancake */
    if (write_error) {
        /* Error handling - set error codes in return buffer */
        var err_addr = return_buffer + RESPONSE_ERR;
        var token_addr = return_buffer + RESPONSE_ERR_TOKEN;
        if (curr_token == I2C_TOKEN_ADDR_READ) {
            !st8 err_addr, I2C_ERR_NOREAD;
        } else {
            !st8 err_addr, I2C_ERR_NACK;
        }
        !st8 token_addr, curr_token;
    } else {
        /* Success - copy data from i2c registers to return buffer using loop */
        var bytes_copied = 0;
        while (bytes_copied < bytes_read) {
            var curr_resp_len = I2C_CURR_RESPONSE_LEN;
            var index = RESPONSE_DATA_OFFSET + curr_resp_len;

            /* Try Pancake implementation instead of FFI */
            var value = 0;

            if (bytes_copied < 4) {
                /* Read directly from rdata0 register byte by byte */
                /* rdata0 is at offset 24 from base, each byte at offset 0,1,2,3 within the 32-bit register */
                var byte_addr = i2c_reg + 24 + bytes_copied;
                !ld8 value, byte_addr;
            } else {
                if (bytes_copied < 8) {
                    /* Read from rdata1 register (offset 28) */
                    /* Bytes 4-7 map to offsets 0-3 within rdata1 */
                    var byte_addr = i2c_reg + 28 + (bytes_copied - 4);
                    !ld8 value, byte_addr;
                }
            }

            /* FFI version - commented out but kept for potential revert */
            /* Store byte index in pancake memory for FFI */
            // st pnk_mem_ptr(25), bytes_copied;
            /* Call FFI to extract the value from register */
            // @get_read_byte(0,0,0,0);
            /* Get the extracted value from scratch slot */
            // var value = pnk_mem(26);

            /* Store value in return buffer */
            var data_addr = return_buffer + index;
            !st8 data_addr, value;

            /* Update response length */
            var new_resp_len = I2C_CURR_RESPONSE_LEN + 1;
            st pnk_mem_ptr(8), new_resp_len;

            bytes_copied = bytes_copied + 1;
        }

        /* Set success status */
        var err_addr = return_buffer + RESPONSE_ERR;
        var token_addr = return_buffer + RESPONSE_ERR_TOKEN;
        !st8 err_addr, I2C_ERR_OK;
        !st8 token_addr, 0;
    }

    /* Check if request is completed or there was an error */
    var remaining = I2C_REMAINING;
    if (write_error || remaining == 0) {
        /* Enqueue response using pancake implementation */
        var 1 resp_queue_ptr = get_response_queue_ptr();
        var bus_address = I2C_ADDR;
        var curr_data = I2C_CURR_DATA;
        var base_data_addr = pnk_mem(21); /* Data region base */
        var offset = curr_data - base_data_addr;
        var response_len = I2C_CURR_RESPONSE_LEN + RESPONSE_DATA_OFFSET;
        i2c_enqueue_pnk(resp_queue_ptr, bus_address, offset, response_len);

        /* Reset driver state */
        st pnk_mem_ptr(8), 0;  /* curr_response_len = 0 */
        st pnk_mem_ptr(6), 0;  /* curr_data = 0 */
        st pnk_mem_ptr(7), 0;  /* curr_request_len = 0 */
        st pnk_mem_ptr(9), 0;  /* remaining = 0 */
        st pnk_mem_ptr(13), 0; /* addr = 0 */

        @microkit_notify_virt(0,0,0,0);
        i2c_halt();
    }

    /* Handle remaining work or deferred notifications */
    var remaining_check = I2C_REMAINING;
    var notified_check = I2C_NOTIFIED;
    if (remaining_check > 0) {
        i2c_load_tokens(); /* Call pancake implementation */
    } else {
        if (notified_check > 0) {
            handle_request(); /* Call pancake implementation */
        }
    }

    return 0;
}

/* Helper functions for bit shifting operations */
/* NOTE: These exist because shift by variable doesn't work in Pancake, only shift by literal */

/* Simulate token << (tk_offset * 4) for 4-bit tokens */
fun token_shift_left(1 token, 1 tk_offset) {
    if (tk_offset == 0) { return token << 0; }   /* No shift */
    if (tk_offset == 1) { return token << 4; }   /* Shift by 4 bits */
    if (tk_offset == 2) { return token << 8; }   /* Shift by 8 bits */
    if (tk_offset == 3) { return token << 12; }  /* Shift by 12 bits */
    if (tk_offset == 4) { return token << 16; }  /* Shift by 16 bits */
    if (tk_offset == 5) { return token << 20; }  /* Shift by 20 bits */
    if (tk_offset == 6) { return token << 24; }  /* Shift by 24 bits */
    if (tk_offset == 7) { return token << 28; }  /* Shift by 28 bits */
    return 0;
}

/* Simulate data << (wdata_offset * 8) for 8-bit data bytes */
fun data_shift_left(1 data, 1 wdata_offset) {
    if (wdata_offset == 0) { return data << 0; }   /* No shift */
    if (wdata_offset == 1) { return data << 8; }   /* Shift by 8 bits */
    if (wdata_offset == 2) { return data << 16; }  /* Shift by 16 bits */
    if (wdata_offset == 3) { return data << 24; }  /* Shift by 24 bits */
    return 0;
}

/* Token conversion helper - uses FFI */
fun convert_token(1 token) {
    st pnk_mem_ptr(14), token;  /* Store token for FFI */
    @i2c_token_convert(0,0,0,0);
    var result = pnk_mem(15);   /* Get result from FFI */
    return result;
}

fun i2c_load_tokens() {
    /* Get token buffer pointer */
    var tokens = I2C_CURR_DATA;
    var remaining = I2C_REMAINING;
    var curr_request_len = I2C_CURR_REQUEST_LEN;

    /* Load address into address register - clear bits 0-7 then set address */
    var addr_reg_addr = i2c_reg + 4;
    var addr_reg = 0;
    !ld32 addr_reg, addr_reg_addr;
    addr_reg = addr_reg & 4294967040; /* ~0xFF = 4294967040 */
    var device_addr = (I2C_ADDR & 127) * 2; /* (addr & 0x7f) << 1 */
    addr_reg = addr_reg | device_addr;
    !st32 addr_reg_addr, addr_reg;

    /* Clear token buffer registers */
    var tk_list0_addr = i2c_reg + 8;
    var tk_list1_addr = i2c_reg + 12;
    var wdata0_addr = i2c_reg + 16;
    var wdata1_addr = i2c_reg + 20;
    !st32 tk_list0_addr, 0;
    !st32 tk_list1_addr, 0;
    !st32 wdata0_addr, 0;
    !st32 wdata1_addr, 0;

    /* Offset variables */
    var tk_offset = 0;
    var wdata_offset = 0;
    var rdata_offset = 0;
    var request_data_offset = curr_request_len - remaining;

    /* Main processing loop - exact logic from C version */
    while (tk_offset < 16 && wdata_offset < 8 && rdata_offset < 8 && request_data_offset < curr_request_len) {
        /* Discover next operation */
        var meson_token = 0;
        var data = 0;
        var rw_remaining = I2C_RW_REMAINING;

        if (rw_remaining == 0) {
            /* Get meson_token if no read/write is in progress */
            var token_addr = tokens + request_data_offset;
            var token = 0;
            !ld8 token, token_addr;
            var 1 converted_token = convert_token(token);
            meson_token = converted_token;

            /* Check if this is ADDR_WRITE or ADDR_READ */
            if (meson_token == MESON_I2C_TOKEN_ADDR_WRITE || meson_token == MESON_I2C_TOKEN_ADDR_READ) {
                /* R/W buffer incoming: get buffer length */
                var len_addr = tokens + request_data_offset + 1;
                var buff_length = 0;
                !ld8 buff_length, len_addr;

                /* Set interface state */
                st pnk_mem_ptr(11), buff_length; /* rw_remaining = buff_length */
                if (meson_token == MESON_I2C_TOKEN_ADDR_WRITE) {
                    st pnk_mem_ptr(12), DATA_DIRECTION_WRITE; /* data_direction = WRITE */
                } else {
                    st pnk_mem_ptr(12), DATA_DIRECTION_READ; /* data_direction = READ */
                }

                /* Skip buffer length byte */
                request_data_offset = request_data_offset + 1;
            }
        } else {
            /* We are in the middle of a read or write */
            var data_direction = I2C_DATA_DIRECTION;
            if (rw_remaining == 1 && data_direction == DATA_DIRECTION_READ) {
                /* Write data end on last byte of a read */
                meson_token = MESON_I2C_TOKEN_DATA_END;
            } else {
                meson_token = MESON_I2C_TOKEN_DATA;
            }
            if (data_direction == DATA_DIRECTION_WRITE) {
                /* Take next byte to write */
                var data_addr = tokens + request_data_offset;
                !ld8 data, data_addr;
            }
            /* Decrement rw_remaining */
            var new_rw_remaining = rw_remaining - 1;
            st pnk_mem_ptr(11), new_rw_remaining;
        }

        /* Pack token into register */
        /* NOTE: Shift by variable doesn't work in Pancake, but shift by literal does */
        if (tk_offset < 8) {
            /* Pack into tk_list0 */
            var tk_list0 = 0;
            !ld32 tk_list0, tk_list0_addr;

            /* Use conditional with literal shifts instead of variable shift */
            if (tk_offset == 0) { tk_list0 = tk_list0 | (meson_token << 0); }
            if (tk_offset == 1) { tk_list0 = tk_list0 | (meson_token << 4); }
            if (tk_offset == 2) { tk_list0 = tk_list0 | (meson_token << 8); }
            if (tk_offset == 3) { tk_list0 = tk_list0 | (meson_token << 12); }
            if (tk_offset == 4) { tk_list0 = tk_list0 | (meson_token << 16); }
            if (tk_offset == 5) { tk_list0 = tk_list0 | (meson_token << 20); }
            if (tk_offset == 6) { tk_list0 = tk_list0 | (meson_token << 24); }
            if (tk_offset == 7) { tk_list0 = tk_list0 | (meson_token << 28); }

            !st32 tk_list0_addr, tk_list0;
        } else {
            /* Pack into tk_list1 */
            var tk_list1 = 0;
            !ld32 tk_list1, tk_list1_addr;
            var offset_mod8 = tk_offset - 8;

            if (offset_mod8 == 0) { tk_list1 = tk_list1 | (meson_token << 0); }
            if (offset_mod8 == 1) { tk_list1 = tk_list1 | (meson_token << 4); }
            if (offset_mod8 == 2) { tk_list1 = tk_list1 | (meson_token << 8); }
            if (offset_mod8 == 3) { tk_list1 = tk_list1 | (meson_token << 12); }
            if (offset_mod8 == 4) { tk_list1 = tk_list1 | (meson_token << 16); }
            if (offset_mod8 == 5) { tk_list1 = tk_list1 | (meson_token << 20); }
            if (offset_mod8 == 6) { tk_list1 = tk_list1 | (meson_token << 24); }
            if (offset_mod8 == 7) { tk_list1 = tk_list1 | (meson_token << 28); }

            !st32 tk_list1_addr, tk_list1;
        }
        tk_offset = tk_offset + 1;

        /* If data token and we are writing, load data into wbuf registers */
        var data_direction = I2C_DATA_DIRECTION;
        if (meson_token == MESON_I2C_TOKEN_DATA && data_direction == DATA_DIRECTION_WRITE) {
            if (wdata_offset < 4) {
                /* Pack into wdata0 */
                var wdata0 = 0;
                !ld32 wdata0, wdata0_addr;
                var 1 shifted_data = data_shift_left(data, wdata_offset);
                // var shifted_data = data << wdata_offset;
                wdata0 = wdata0 | shifted_data;
                !st32 wdata0_addr, wdata0;
            } else {
                /* Pack into wdata1 */
                var wdata1 = 0;
                !ld32 wdata1, wdata1_addr;
                var offset_minus4 = wdata_offset - 4;
                var 1 shifted_data = data_shift_left(data, offset_minus4);
                wdata1 = wdata1 | shifted_data;
                !st32 wdata1_addr, wdata1;
            }
            wdata_offset = wdata_offset + 1;
        }

        /* If data token and we are reading, increment counter of rdata */
        if ((meson_token == MESON_I2C_TOKEN_DATA || meson_token == MESON_I2C_TOKEN_DATA_END)
            && data_direction == DATA_DIRECTION_READ) {
            rdata_offset = rdata_offset + 1;
        }

        request_data_offset = request_data_offset + 1;
    }

    /* Update remaining tokens indicator */
    var new_remaining = curr_request_len - request_data_offset;
    st pnk_mem_ptr(9), new_remaining; /* remaining = curr_request_len - request_data_offset */

    /* Start list processor */
    i2c_start();

    return 0;
}

/* Start I2C list processor */
fun i2c_start() {
    var ctl_addr = i2c_reg + 0;
    var ctl = 0;
    !ld32 ctl, ctl_addr;
    ctl = ctl & 4294967294; /* clear bit 0 */
    !st32 ctl_addr, ctl;
    ctl = ctl | 1; /* set bit 0 */
    !st32 ctl_addr, ctl;
    return 0;
}

/* Handle incoming I2C requests */
fun handle_request() {
    /* Get request queue pointer and check if empty */
    var 1 req_queue_ptr = get_request_queue_ptr();
    var 1 queue_empty = i2c_queue_empty_pnk(req_queue_ptr);

    if (queue_empty == 0) {  /* Queue is not empty */
        /* Check if this interface is busy */
        var curr_data = I2C_CURR_DATA;
        if (curr_data != 0) {
            /* Driver busy - defer notification until later */
            st pnk_mem_ptr(10), 1; /* notified = 1 */
            return 0;
        }

        /* Begin work - extract the request */
        i2c_dequeue_pnk(req_queue_ptr);
        var err = pnk_mem(17);
        var bus_address = pnk_mem(18);
        var offset = pnk_mem(19);
        var size = pnk_mem(20);

        if (err != 0) {
            /* Failed to dequeue request */
            return 0;
        }

        if (size > I2C_MAX_DATA_SIZE) {
            /* Invalid request size */
            return 0;
        }

        if (bus_address > MESON_I2C_MAX_BUS_ADDRESS) {
            /* Address out of 7-bit range */
            return 0;
        }

        /* Set up driver state for new request */
        /* curr_data = base_addr + offset */
        /* Note: In pancake mode, we store the full address as uint64_t */
        var base_data_addr = pnk_mem(21); /* Data region base stored during init */
        var curr_data_addr = base_data_addr + offset;
        st pnk_mem_ptr(6), curr_data_addr;  /* curr_data */
        st pnk_mem_ptr(13), bus_address;    /* addr */
        st pnk_mem_ptr(7), size;            /* curr_request_len */
        st pnk_mem_ptr(9), size;            /* remaining */
        st pnk_mem_ptr(10), 0;              /* notified = 0 */

        /* Load tokens and start I2C operation */
        i2c_load_tokens();
    } else {
        /* No work available - clear notified flag */
        st pnk_mem_ptr(10), 0; /* notified = 0 */
    }

    return 0;
}

fun main() {
    return 0;
}

export fun notified(1 ch) {
    if (ch == virt_ch) {
        handle_request(); /* Call pancake implementation */
    } else {
        if (ch == irq_ch_0) {
            // @handle_response(0,0,0,0);  /* Call pancake implementation */
            handle_response();
            microkit_deferred_irq_ack(ch)
        } else {
            if (ch == irq_ch_1) {
                @handle_response_timeout(0,0,0,0);
                microkit_deferred_irq_ack(ch)
            } else {
                // error
            }
        }
    }
    return 0;
}
