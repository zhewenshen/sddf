/*
 * Copyright 2025, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */

#define I2C_REGS_BASE           pnk_mem(0)
#define IRQ_CH                  pnk_mem(1)
#define TIMEOUT_IRQ_CH          pnk_mem(2)
#define VIRT_CH                 pnk_mem(3)
#define I2C_REQ_QUEUE           pnk_mem(4)
#define I2C_RESP_QUEUE          pnk_mem(5)
#define DATA_REGION_VADDR       pnk_mem(6)
#define CURR_DATA_PTR           pnk_mem(7)
#define CURR_REQUEST_LEN        pnk_mem(8)
#define CURR_RESPONSE_LEN       pnk_mem(9)
#define REMAINING               pnk_mem(10)
#define NOTIFIED                pnk_mem(11)
#define RW_REMAINING            pnk_mem(12)
#define DATA_DIRECTION          pnk_mem(13)
#define CURR_ADDR               pnk_mem(14)

#define DATA_DIRECTION_WRITE 0
#define DATA_DIRECTION_READ 1

#define REG_CTL_OFFSET          0
#define REG_ADDR_OFFSET         4
#define REG_TK_LIST0_OFFSET     8
#define REG_TK_LIST1_OFFSET     12
#define REG_WDATA0_OFFSET       16
#define REG_WDATA1_OFFSET       20
#define REG_RDATA0_OFFSET       24
#define REG_RDATA1_OFFSET       28

#define REG_CTRL_START          1
#define REG_CTRL_ACK_IGNORE     2
#define REG_CTRL_STATUS         4
#define REG_CTRL_ERROR          8
#define REG_CTRL_CURR_TK_SHIFT  4
#define REG_CTRL_CURR_TK_MASK   240
#define REG_CTRL_RD_CNT_SHIFT   8
#define REG_CTRL_RD_CNT_MASK    3840
#define REG_CTRL_MANUAL         4194304
#define REG_CTRL_CNTL_JIC       2147483648
#define REG_CTRL_CLKDIV_SHIFT   12
#define REG_CTRL_CLKDIV_MASK    4190208

#define REG_ADDR_SCLDELAY_SHFT  16
#define REG_ADDR_SDAFILTER      1792
#define REG_ADDR_SCLFILTER      14336
#define REG_ADDR_SCLDELAY_ENABLE 268435456

#define MESON_I2C_TOKEN_END         0
#define MESON_I2C_TOKEN_START       1
#define MESON_I2C_TOKEN_ADDR_WRITE  2
#define MESON_I2C_TOKEN_ADDR_READ   3
#define MESON_I2C_TOKEN_DATA        4
#define MESON_I2C_TOKEN_DATA_END    5
#define MESON_I2C_TOKEN_STOP        6

#define I2C_TOKEN_END           0
#define I2C_TOKEN_START         1
#define I2C_TOKEN_ADDR_WRITE    2
#define I2C_TOKEN_ADDR_READ     3
#define I2C_TOKEN_STOP          4

#define MESON_I2C_MAX_BUS_ADDRESS 127
#define I2C_MAX_DATA_SIZE 128

#define RESPONSE_ERR 0
#define RESPONSE_ERR_TOKEN 1
#define RESPONSE_DATA_OFFSET 2
#define I2C_ERR_OK 0
#define I2C_ERR_TIMEOUT 1
#define I2C_ERR_NACK 2
#define I2C_ERR_NOREAD 3
#define I2C_ERR_OTHER 3

fun i2c_token_convert(1 token)
{
  if (token == I2C_TOKEN_END) { return MESON_I2C_TOKEN_END; }
  if (token == I2C_TOKEN_START) { return MESON_I2C_TOKEN_START; }
  if (token == I2C_TOKEN_ADDR_WRITE) { return MESON_I2C_TOKEN_ADDR_WRITE; }
  if (token == I2C_TOKEN_ADDR_READ) { return MESON_I2C_TOKEN_ADDR_READ; }
  if (token == I2C_TOKEN_STOP) { return MESON_I2C_TOKEN_STOP; }
  return MESON_I2C_TOKEN_END;
}

fun i2c_start()
{
  var ctl_reg = I2C_REGS_BASE + REG_CTL_OFFSET;
  
  var ctl = 0;
  !ld32 ctl, ctl_reg;
  
  ctl = ctl | REG_CTRL_START;
  !st32 ctl_reg, ctl;
  
  return 0;
}

fun i2c_halt()
{
  var ctl_reg = I2C_REGS_BASE + REG_CTL_OFFSET;
  
  var ctl = 0;
  !ld32 ctl, ctl_reg;
  
  var not_start = 4294967295 ^ REG_CTRL_START;
  ctl = ctl & not_start;
  !st32 ctl_reg, ctl;
  
  return 0;
}

fun i2c_get_error()
{
  var ctl_reg = I2C_REGS_BASE + REG_CTL_OFFSET;
  
  var ctl = 0;
  !ld32 ctl, ctl_reg;
  
  var err = (ctl & REG_CTRL_ERROR) >> 3;
  var bytes_read = (ctl & REG_CTRL_RD_CNT_MASK) >> REG_CTRL_RD_CNT_SHIFT;
  var curr_token = (ctl & REG_CTRL_CURR_TK_MASK) >> REG_CTRL_CURR_TK_SHIFT;
  
  return <err, bytes_read, curr_token>;
}

fun i2c_load_tokens()
{
  var curr_data = CURR_DATA_PTR;
  var remaining = REMAINING;
  var curr_request_len = CURR_REQUEST_LEN;
  var addr = CURR_ADDR;
  var rw_remaining = RW_REMAINING;
  var data_direction = DATA_DIRECTION;
  
  var addr_lo7 = (addr & 127) * 2;
  var addr_reg = I2C_REGS_BASE + REG_ADDR_OFFSET;
  var curr_addr_val = 0;
  !ld32 curr_addr_val, addr_reg;
  var not_255 = 4294967295 ^ 255;
  curr_addr_val = curr_addr_val & not_255;
  curr_addr_val = curr_addr_val | addr_lo7;
  !st32 addr_reg, curr_addr_val;
  
  !st32 I2C_REGS_BASE + REG_TK_LIST0_OFFSET, 0;
  !st32 I2C_REGS_BASE + REG_TK_LIST1_OFFSET, 0;
  !st32 I2C_REGS_BASE + REG_WDATA0_OFFSET, 0;
  !st32 I2C_REGS_BASE + REG_WDATA1_OFFSET, 0;
  
  var tk_offset = 0;
  var wdata_offset = 0;
  var rdata_offset = 0;
  var request_data_offset = curr_request_len - remaining;
  
  var regs_base = I2C_REGS_BASE;
  
  while ((tk_offset < 16) && (wdata_offset < 8) && (rdata_offset < 8) && (request_data_offset < curr_request_len)) {
    var meson_token = 0;
    var data = 0;
    
    if (rw_remaining == 0) {
      var token = 0;
      !ld8 token, curr_data + request_data_offset;
      var 1 converted_token = i2c_token_convert(token);
      meson_token = converted_token;
      
      if ((meson_token == MESON_I2C_TOKEN_ADDR_WRITE) || (meson_token == MESON_I2C_TOKEN_ADDR_READ)) {
        request_data_offset = request_data_offset + 1;
        var buff_length = 0;
        !ld8 buff_length, curr_data + request_data_offset;
        
        rw_remaining = buff_length;
        !st32 pnk_mem_ptr(12), buff_length;
        
        if (meson_token == MESON_I2C_TOKEN_ADDR_WRITE) {
          data_direction = DATA_DIRECTION_WRITE;
          !st32 pnk_mem_ptr(13), DATA_DIRECTION_WRITE;
        } else {
          data_direction = DATA_DIRECTION_READ;
          !st32 pnk_mem_ptr(13), DATA_DIRECTION_READ;
        }
      }
    } else {
      if ((rw_remaining == 1) && (data_direction == DATA_DIRECTION_READ)) {
        meson_token = MESON_I2C_TOKEN_DATA_END;
      } else {
        meson_token = MESON_I2C_TOKEN_DATA;
      }
      
      if (data_direction == DATA_DIRECTION_WRITE) {
        !ld8 data, curr_data + request_data_offset;
      }
      
      rw_remaining = rw_remaining - 1;
      !st32 pnk_mem_ptr(12), rw_remaining;
    }
    
    if (tk_offset < 8) {
      var tk_list0_reg = I2C_REGS_BASE + REG_TK_LIST0_OFFSET;
      var tk_list0 = 0;
      !ld32 tk_list0, tk_list0_reg;
      var shift_amount = tk_offset * 4;
      var power_of_2 = 1;
      if (shift_amount == 4) { power_of_2 = 16; }
      if (shift_amount == 8) { power_of_2 = 256; }
      if (shift_amount == 12) { power_of_2 = 4096; }
      if (shift_amount == 16) { power_of_2 = 65536; }
      if (shift_amount == 20) { power_of_2 = 1048576; }
      if (shift_amount == 24) { power_of_2 = 16777216; }
      if (shift_amount == 28) { power_of_2 = 268435456; }
      var shifted_token = meson_token * power_of_2;
      tk_list0 = tk_list0 | shifted_token;
      !st32 tk_list0_reg, tk_list0;
    } else {
      var tk_list1_reg = regs_base + REG_TK_LIST1_OFFSET;
      var tk_list1 = 0;
      !ld32 tk_list1, tk_list1_reg;
      var offset_mod = tk_offset & 7;
      var shift_amount1 = offset_mod * 4;
      var power_of_2_1 = 1;
      if (shift_amount1 == 4) { power_of_2_1 = 16; }
      if (shift_amount1 == 8) { power_of_2_1 = 256; }
      if (shift_amount1 == 12) { power_of_2_1 = 4096; }
      if (shift_amount1 == 16) { power_of_2_1 = 65536; }
      if (shift_amount1 == 20) { power_of_2_1 = 1048576; }
      if (shift_amount1 == 24) { power_of_2_1 = 16777216; }
      if (shift_amount1 == 28) { power_of_2_1 = 268435456; }
      var shifted_token1 = meson_token * power_of_2_1;
      tk_list1 = tk_list1 | shifted_token1;
      !st32 tk_list1_reg, tk_list1;
    }
    tk_offset = tk_offset + 1;
    
    if ((meson_token == MESON_I2C_TOKEN_DATA) && (data_direction == DATA_DIRECTION_WRITE)) {
      if (wdata_offset < 4) {
        var wdata0_reg = regs_base + REG_WDATA0_OFFSET;
        var wdata0 = 0;
        !ld32 wdata0, wdata0_reg;
        var wdata_shift = wdata_offset * 8;
        var wdata_power = 1;
        if (wdata_shift == 8) { wdata_power = 256; }
        if (wdata_shift == 16) { wdata_power = 65536; }
        if (wdata_shift == 24) { wdata_power = 16777216; }
        var shifted_data = data * wdata_power;
        wdata0 = wdata0 | shifted_data;
        !st32 wdata0_reg, wdata0;
      } else {
        var wdata1_reg = regs_base + REG_WDATA1_OFFSET;
        var wdata1 = 0;
        !ld32 wdata1, wdata1_reg;
        var offset_mod = wdata_offset - 4;
        var wdata1_shift = offset_mod * 8;
        var wdata1_power = 1;
        if (wdata1_shift == 8) { wdata1_power = 256; }
        if (wdata1_shift == 16) { wdata1_power = 65536; }
        if (wdata1_shift == 24) { wdata1_power = 16777216; }
        var shifted_data1 = data * wdata1_power;
        wdata1 = wdata1 | shifted_data1;
        !st32 wdata1_reg, wdata1;
      }
      wdata_offset = wdata_offset + 1;
    }
    
    if (((meson_token == MESON_I2C_TOKEN_DATA) || (meson_token == MESON_I2C_TOKEN_DATA_END)) && 
        (data_direction == DATA_DIRECTION_READ)) {
      rdata_offset = rdata_offset + 1;
    }
    
    request_data_offset = request_data_offset + 1;
  }
  
  var new_remaining = curr_request_len - request_data_offset;
  !st32 pnk_mem_ptr(10), new_remaining;
  
  i2c_start();
  return 0;
}

fun handle_request()
{
  var req_queue = I2C_REQ_QUEUE;
  var 1 is_empty = i2c_queue_empty(req_queue);
  
  if (!is_empty) {
    var curr_data = CURR_DATA_PTR;
    if (curr_data != 0) {
      !st32 pnk_mem_ptr(11), 1;
      return 0;
    }
    
    var {1,1,1,1} dequeue_result = i2c_dequeue_request(req_queue);
    var err = dequeue_result.0;
    var bus_address = dequeue_result.1;
    var offset = dequeue_result.2;
    var size = dequeue_result.3;
    
    if (err) {
      return 0;
    }
    
    if (size > I2C_MAX_DATA_SIZE) {
      return 0;
    }
    
    if (bus_address > MESON_I2C_MAX_BUS_ADDRESS) {
      return 0;
    }
    
    var data_vaddr = DATA_REGION_VADDR;
    var new_curr_data = data_vaddr + offset;
    
    !st32 pnk_mem_ptr(7), new_curr_data;
    !st32 pnk_mem_ptr(14), bus_address;
    !st32 pnk_mem_ptr(8), size;
    !st32 pnk_mem_ptr(10), size;
    !st32 pnk_mem_ptr(11), 0;
    
    i2c_load_tokens();
  } else {
    !st32 pnk_mem_ptr(11), 0;
  }
  
  return 0;
}

fun handle_response()
{
  var {1,1,1} error_result = i2c_get_error();
  var write_error = error_result.0;
  var bytes_read = error_result.1;
  var curr_token = error_result.2;
  
  var data_vaddr = DATA_REGION_VADDR;
  var curr_data = CURR_DATA_PTR;
  var offset = curr_data - data_vaddr;
  var return_buffer = curr_data;
  
  var curr_response_len = CURR_RESPONSE_LEN;
  var remaining = REMAINING;
  
  if (write_error) {
    !st8 return_buffer + RESPONSE_ERR, I2C_ERR_NACK;
    !st8 return_buffer + RESPONSE_ERR_TOKEN, curr_token;
  } else {
    var i = 0;
    
    while (true) {
      if (i >= bytes_read) {
        break;
      }
      
      var rdata_reg = I2C_REGS_BASE + REG_RDATA0_OFFSET;
      if (i >= 4) {
        rdata_reg = I2C_REGS_BASE + REG_RDATA1_OFFSET;
      }
      
      var rdata = 0;
      !ld32 rdata, rdata_reg;
      
      var byte_offset = i;
      if (i >= 4) {
        byte_offset = i - 4;
      }
      
      var shift_amount = byte_offset * 8;
      var extracted_byte = 0;
      
      if (shift_amount == 0) {
        extracted_byte = rdata & 255;
      }
      if (shift_amount == 8) {
        var shifted = rdata >> 8;
        extracted_byte = shifted & 255;
      }
      if (shift_amount == 16) {
        var shifted = rdata >> 16;
        extracted_byte = shifted & 255;
      }
      if (shift_amount == 24) {
        var shifted = rdata >> 24;
        extracted_byte = shifted & 255;
      }
      
      !st8 return_buffer + RESPONSE_DATA_OFFSET + i, extracted_byte;
      
      i = i + 1;
    }
    
    var new_response_len = curr_response_len + bytes_read;
    !st32 pnk_mem_ptr(9), new_response_len;
    
    !st8 return_buffer + RESPONSE_ERR, I2C_ERR_OK;
    !st8 return_buffer + RESPONSE_ERR_TOKEN, 0;
  }
  
  if (write_error || (remaining == 0)) {
    var resp_queue = I2C_RESP_QUEUE;
    var addr = CURR_ADDR;
    var resp_len = curr_response_len + RESPONSE_DATA_OFFSET;
    
    var 1 ret = i2c_enqueue_response(resp_queue, addr, offset, resp_len);
    
    !st32 pnk_mem_ptr(9), 0;
    !st32 pnk_mem_ptr(7), 0;
    !st32 pnk_mem_ptr(8), 0;
    !st32 pnk_mem_ptr(10), 0;
    !st32 pnk_mem_ptr(14), 0;
    
    var virt_ch = VIRT_CH;
    microkit_notify(virt_ch)
    
    i2c_halt();
  }
  
  if (remaining) {
    i2c_load_tokens();
  } else {
    var notified = NOTIFIED;
    if (notified) {
      handle_request();
    }
  }
  
  return 0;
}

fun handle_response_timeout()
{
  var data_vaddr = DATA_REGION_VADDR;
  var curr_data = CURR_DATA_PTR;
  var offset = curr_data - data_vaddr;
  var return_buffer = curr_data;
  
  !st8 return_buffer + RESPONSE_ERR, I2C_ERR_TIMEOUT;
  !st8 return_buffer + RESPONSE_ERR_TOKEN, 0;
  
  var resp_queue = I2C_RESP_QUEUE;
  var addr = CURR_ADDR;
  var curr_response_len = CURR_RESPONSE_LEN;
  var resp_len = curr_response_len + RESPONSE_DATA_OFFSET;
  
  var 1 ret = i2c_enqueue_response(resp_queue, addr, offset, resp_len);
  
  !st32 pnk_mem_ptr(9), 0;
  !st32 pnk_mem_ptr(7), 0;
  !st32 pnk_mem_ptr(8), 0;
  !st32 pnk_mem_ptr(10), 0;
  !st32 pnk_mem_ptr(14), 0;
  
  var virt_ch = VIRT_CH;
  microkit_notify(virt_ch)
  
  i2c_halt();
  
  var notified = NOTIFIED;
  if (notified) {
    handle_request();
  }
  
  return 0;
}

export fun notified(1 ch)
{
  var virt_ch = VIRT_CH;
  var irq_ch = IRQ_CH;
  var timeout_irq_ch = TIMEOUT_IRQ_CH;
  
  if (ch == virt_ch) {
    handle_request();
  }
  if (ch == irq_ch) {
    handle_response();
    microkit_deferred_irq_ack(ch)
  }
  if (ch == timeout_irq_ch) {
    handle_response_timeout();
    microkit_deferred_irq_ack(ch)
  }
  
  return 0;
}
