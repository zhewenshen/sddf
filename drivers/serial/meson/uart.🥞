/*
 * Copyright 2025, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */

/////////////////// Pancake driver memory layout
#define IRQ_CH  pnk_mem(1)
#define RX_CH   pnk_mem(2)  
#define TX_CH   pnk_mem(3)

/* Mirror `serial_queue_handle_t` struct */
/* RX Queue Handle */
#define SERIAL_RX_QUEUE     pnk_mem(4)   // queue pointer
#define SERIAL_RX_CAPACITY  pnk_mem(5)   // capacity
#define SERIAL_RX_DATA      pnk_mem(6)   // data_region pointer

/* TX Queue Handle */
#define SERIAL_TX_QUEUE     pnk_mem(7)   // queue pointer  
#define SERIAL_TX_CAPACITY  pnk_mem(8)   // capacity
#define SERIAL_TX_DATA      pnk_mem(9)   // data_region pointer

/* UART register base */
#define UART_REG_BASE       pnk_mem(0)

#define RX_ENABLED          pnk_mem(1024)

/////////////////// UART Hardware Constants
/* Register offsets */
#define WFIFO_OFFSET        0
#define RFIFO_OFFSET        4
#define CR_OFFSET           8
#define SR_OFFSET           12

/* Status Register bits */
#define AML_UART_RX_EMPTY   (1 << 20)
#define AML_UART_TX_FULL    (1 << 21)
#define AML_UART_TX_BUSY    (1 << 25)
#define AML_UART_RX_BUSY    (1 << 26)

/* Control Register bits */
#define AML_UART_RX_INT_EN  (1 << 27)
#define AML_UART_TX_INT_EN  (1 << 28)
#define AML_UART_CLEAR_ERR  (1 << 24)

/* Interrupt bits */
#define AML_UART_PARITY_ERR (1 << 16)
#define AML_UART_FRAME_ERR  (1 << 17)
#define AML_UART_TX_FIFO_WERR (1 << 18)
#define UART_INTR_ABNORMAL  (AML_UART_PARITY_ERR | AML_UART_FRAME_ERR | AML_UART_TX_FIFO_WERR)

#define AML_UART_RX_INT_EN_MASK  4160749567  // ~(1 << 27) = 0xF7FFFFFF
#define AML_UART_TX_INT_EN_MASK  4026531839  // ~(1 << 28) = 0xEFFFFFFF

/////////////////// Hardware Helper Functions

fun uart_read_sr()
{
  var reg_addr = UART_REG_BASE + SR_OFFSET;
  var sr = 0;
  !ld32 sr, reg_addr;
  return sr;
}

fun uart_read_cr()
{
  var reg_addr = UART_REG_BASE + CR_OFFSET;
  var cr = 0;
  !ld32 cr, reg_addr;
  return cr;
}

fun uart_write_cr(1 cr)
{
  var reg_addr = UART_REG_BASE + CR_OFFSET;
  !st32 reg_addr, cr;
  return 0;
}

fun uart_read_char()
{
  var reg_addr = UART_REG_BASE + RFIFO_OFFSET;
  var c = 0;
  !ld8 c, reg_addr;
  return c;
}

fun uart_write_char(1 c)
{
  var reg_addr = UART_REG_BASE + WFIFO_OFFSET;
  !st8 reg_addr, c;
  return 0;
}

/////////////////// Serial Queue Helper Functions

fun serial_queue_get_head(1 queue_ptr)
{
  var head = 0;
  !ld32 head, queue_ptr + 4;
  return head;
}

fun serial_queue_get_tail(1 queue_ptr)
{
  var tail = 0;
  !ld32 tail, queue_ptr;
  return tail;
}

/////////////////// Main Driver Functions

export fun tx_provide()
{
  var transferred = false;
  var tx_queue = SERIAL_TX_QUEUE;
  var tx_capacity = SERIAL_TX_CAPACITY;
  var tx_data = SERIAL_TX_DATA;

  while (true)
  {
    var 1 sr = uart_read_sr();
    if (sr & AML_UART_TX_FULL) { break; }

    // Try to dequeue a character
    var 1 head = serial_queue_get_head(tx_queue);
    var 1 tail = serial_queue_get_tail(tx_queue);
    if (head == tail) { break; } // Queue empty

    // Calculate position and read character
    var pos = head & (tx_capacity - 1);
    var char_addr = tx_data + pos;
    var c = 0;
    !ld8 c, char_addr;

    // Send character to UART
    uart_write_char(c);
    transferred = true;

    // Update head
    var new_head = head + 1;
    !st32 tx_queue + 4, new_head;
  }

  // Handle TX interrupt enable/disable
  var 1 sr = uart_read_sr();
  var 1 cr = uart_read_cr();
  var 1 head = serial_queue_get_head(tx_queue);
  var 1 tail = serial_queue_get_tail(tx_queue);
  
  if ((sr & AML_UART_TX_FULL) && (head != tail)) {
    // TX FIFO full and data remaining - enable interrupt
    cr = cr | AML_UART_TX_INT_EN;
    uart_write_cr(cr);
  } else {
    // No data or FIFO not full - disable interrupt  
    cr = cr & AML_UART_TX_INT_EN_MASK;
    uart_write_cr(cr);
  }

  // Check if need to signal consumer
  var signalled = 0;
  !ld32 signalled, tx_queue + 8;
  if (transferred && (!signalled)) {
    !st32 tx_queue + 8, 1; // Cancel signal
    microkit_notify(TX_CH)
  }

  return 0;
}

export fun rx_return()
{
  var reprocess = true;
  var enqueued = false;
  var rx_queue = SERIAL_RX_QUEUE;
  var rx_capacity = SERIAL_RX_CAPACITY;
  var rx_data = SERIAL_RX_DATA;

  while (reprocess)
  {
    // Read characters while UART has data and queue has space
    while (true)
    {
      var 1 sr = uart_read_sr();
      if (sr & AML_UART_RX_EMPTY) { break; }

      var 1 head = serial_queue_get_head(rx_queue);
      var 1 tail = serial_queue_get_tail(rx_queue);
      var used = tail - head;
      if (used == rx_capacity) { break; } // Queue full

      // Read character from UART
      var 1 c = uart_read_char();

      // Enqueue character
      var pos = tail & (rx_capacity - 1);
      var char_addr = rx_data + pos;
      !st8 char_addr, c;

      // Update tail
      var new_tail = tail + 1;
      !st32 rx_queue, new_tail;
      enqueued = true;
    }

    // Handle interrupt control when queue full
    var 1 sr = uart_read_sr();
    var 1 head = serial_queue_get_head(rx_queue);
    var 1 tail = serial_queue_get_tail(rx_queue);
    var used = tail - head;
    
    if ((!(sr & AML_UART_RX_EMPTY)) && (used == rx_capacity)) {
      // UART has data but queue full - disable RX interrupt and request signal
      var 1 cr = uart_read_cr();
      cr = cr & AML_UART_RX_INT_EN_MASK;
      uart_write_cr(cr);
      !st32 rx_queue + 8, 0; // Request signal
    }
    
    reprocess = false;

    // Check if we can re-enable interrupts
    if ((!(sr & AML_UART_RX_EMPTY)) && (used != rx_capacity)) {
      !st32 rx_queue + 8, 1; // Cancel signal
      var 1 cr = uart_read_cr();
      cr = cr | AML_UART_RX_INT_EN;
      uart_write_cr(cr);
      reprocess = true;
    }
  }

  if (enqueued) {
    microkit_notify(RX_CH)
  }

  return 0;
}

export fun handle_irq()
{
  var 1 uart_sr = uart_read_sr();
  var 1 uart_cr = uart_read_cr();

  while ((uart_sr & UART_INTR_ABNORMAL) || (!(uart_sr & AML_UART_RX_EMPTY)) ||
         ((uart_cr & AML_UART_TX_INT_EN) && (!(uart_sr & AML_UART_TX_FULL))))
  {
    // Handle RX if enabled and data available
    if (RX_ENABLED && !(uart_sr & AML_UART_RX_EMPTY)) {
      rx_return();
    }

    // Handle TX if interrupt enabled and FIFO not full
    if ((uart_cr & AML_UART_TX_INT_EN) && (!(uart_sr & AML_UART_TX_FULL))) {
      tx_provide();
    }

    // Handle errors
    if (uart_sr & UART_INTR_ABNORMAL) {
      // Clear errors
      var 1 cr = uart_read_cr();
      cr = cr | AML_UART_CLEAR_ERR;
      uart_write_cr(cr);
    }

    uart_sr = uart_read_sr();
    uart_cr = uart_read_cr();
  }

  return 0;
}

/////////////////// Main Entry Points

export fun notified(1 ch)
{
  if (ch == IRQ_CH) {
    handle_irq();
    microkit_deferred_irq_ack(ch)
    return 0;
  }

  if (ch == TX_CH) {
    tx_provide();
    return 0;
  }

  if (ch == RX_CH) {
    var 1 cr = uart_read_cr();
    cr = cr | AML_UART_RX_INT_EN;
    uart_write_cr(cr);

    rx_return();
    return 0;
  }

  return 0;
}
