/*
 * Copyright 2025, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */

#define UART_REG_BASE       pnk_mem(0)
#define IRQ_CH              pnk_mem(1)
#define RX_CH               pnk_mem(2)
#define TX_CH               pnk_mem(3)
#define SERIAL_RX_QUEUE     pnk_mem(4)
#define SERIAL_RX_CAPACITY  pnk_mem(5)
#define SERIAL_RX_DATA      pnk_mem(6)
#define SERIAL_TX_QUEUE     pnk_mem(7)
#define SERIAL_TX_CAPACITY  pnk_mem(8)
#define SERIAL_TX_DATA      pnk_mem(9)

#define RX_ENABLED          pnk_mem(1024)
#define REG_SHIFT           pnk_mem(1025)
#define DW_APB_REGISTERS    pnk_mem(1026)

#define UART_RBR    0
#define UART_THR    0
#define UART_DLL    0
#define UART_DLH    1
#define UART_IER    1
#define UART_IIR    2
#define UART_FCR    2
#define UART_LCR    3
#define UART_MCR    4
#define UART_LSR    5
#define UART_USR    31

#define UART_IER_ERBFI      1
#define UART_IER_ETBEI      2

#define UART_IIR_IID_MASK   7
#define UART_IIR_IID_THRI   2
#define UART_IIR_IID_RDI    4

#define UART_FCR_FIFOE      1
#define UART_FCR_RFIFOR     2
#define UART_FCR_XFIFOR     4

#define UART_LCR_DLAB       128

#define UART_MCR_DTR        1
#define UART_MCR_RTS        2

#define UART_LSR_DR         1
#define UART_LSR_PE         4
#define UART_LSR_FE         8
#define UART_LSR_THRE       32
#define UART_LSR_TEMT       64
#define UART_LSR_RFE        128

#define UART_USR_BUSY       1
#define UART_USR_TFNF       2

#define UART_IER_ERBFI_MASK     4294967294
#define UART_IER_ETBEI_MASK     4294967293

fun uart_read_reg(1 offset)
{
  var reg_shift = REG_SHIFT;
  var shifted_offset = offset;
  
  if (reg_shift == 2) {
    shifted_offset = offset * 4;
  }
  
  var reg_addr = UART_REG_BASE + shifted_offset;
  var val = 0;
  
  if (reg_shift == 0) {
    !ld8 val, reg_addr;
    return val;
  }
  
  if (reg_shift == 2) {
    !ld32 val, reg_addr;
    return val;
  }
  
  return 0;
}

fun uart_write_reg(1 offset, 1 val)
{
  var reg_shift = REG_SHIFT;
  var shifted_offset = offset;
  
  if (reg_shift == 2) {
    shifted_offset = offset * 4;
  }
  
  var reg_addr = UART_REG_BASE + shifted_offset;
  
  if (reg_shift == 0) {
    !st8 reg_addr, val;
    return 0;
  }
  
  if (reg_shift == 2) {
    !st32 reg_addr, val;
    return 0;
  }
  
  return 0;
}

fun tx_fifo_not_full()
{
  var dw_apb_regs = DW_APB_REGISTERS;
  if (dw_apb_regs) {
    var 1 usr = uart_read_reg(UART_USR);
    return (usr & UART_USR_TFNF);
  }
  
  var 1 lsr = uart_read_reg(UART_LSR);
  return (lsr & UART_LSR_THRE);
}

fun rx_has_data()
{
  var 1 lsr = uart_read_reg(UART_LSR);
  return (lsr & UART_LSR_DR);
}


fun tx_provide()
{
  var transferred = 0;
  var tx_queue = SERIAL_TX_QUEUE;
  var tx_capacity = SERIAL_TX_CAPACITY; 
  var tx_data = SERIAL_TX_DATA;
  
  var 1 fifo_not_full = tx_fifo_not_full();
  var 1 queue_empty = serial_queue_is_empty(tx_queue);

  while (fifo_not_full && !queue_empty) {
    var 1 c = serial_queue_dequeue_char(tx_queue, tx_capacity, tx_data);
    uart_write_reg(UART_THR, c);
    transferred = 1;
    
    fifo_not_full = tx_fifo_not_full();
    queue_empty = serial_queue_is_empty(tx_queue);
  }

  queue_empty = serial_queue_is_empty(tx_queue);
  if (!queue_empty) {
    var 1 ier = uart_read_reg(UART_IER);
    ier = ier | UART_IER_ETBEI;
    uart_write_reg(UART_IER, ier);
  }
  
  if (queue_empty) {
    var 1 ier = uart_read_reg(UART_IER);
    ier = ier & UART_IER_ETBEI_MASK;
    uart_write_reg(UART_IER, ier);
  }

  if (transferred) {
    var 1 requires_signal = serial_queue_require_signal(tx_queue);
    if (requires_signal) {
      serial_queue_cancel_signal(tx_queue);
      var tx_ch = TX_CH;
      microkit_notify(tx_ch)
    }
  }

  return 0;
}

fun rx_return()
{
  var rx_enabled = RX_ENABLED;
  if (!rx_enabled) {
    return 0;
  }

  var reprocess = 1;
  var enqueued = 0;

  var rx_queue = SERIAL_RX_QUEUE;
  var rx_capacity = SERIAL_RX_CAPACITY;
  var rx_data = SERIAL_RX_DATA;
  
  while (reprocess) {
    var 1 has_data = rx_has_data();
    var 1 queue_full = serial_queue_is_full(rx_queue, rx_capacity);
    
    while (has_data && !queue_full) {
      var 1 c = uart_read_reg(UART_RBR);
      serial_queue_enqueue_char(rx_queue, rx_capacity, rx_data, c);
      enqueued = 1;
      
      has_data = rx_has_data();
      queue_full = serial_queue_is_full(rx_queue, rx_capacity);
    }

    has_data = rx_has_data();
    queue_full = serial_queue_is_full(rx_queue, rx_capacity);
    
    if (has_data && queue_full) {
      var 1 ier = uart_read_reg(UART_IER);
      ier = ier & UART_IER_ERBFI_MASK;
      uart_write_reg(UART_IER, ier);
      serial_queue_request_signal(rx_queue);
    }
    
    reprocess = 0;

    if (has_data && !queue_full) {
      serial_queue_cancel_signal(rx_queue);
      var 1 ier = uart_read_reg(UART_IER);
      ier = ier | UART_IER_ERBFI;
      uart_write_reg(UART_IER, ier);
      reprocess = 1;
    }
  }

  if (enqueued) {
    var rx_ch = RX_CH;
    microkit_notify(rx_ch)
  }

  return 0;
}

fun handle_irq()
{
  var 1 line_status = uart_read_reg(UART_LSR);
  if (line_status & (UART_LSR_PE | UART_LSR_FE | UART_LSR_RFE)) {
    
  }

  var 1 irq_id = uart_read_reg(UART_IIR);
  irq_id = irq_id & UART_IIR_IID_MASK;
  
  var rx_enabled = RX_ENABLED;
  if (rx_enabled && (irq_id == UART_IIR_IID_RDI)) {
    rx_return();
  }
  
  if (irq_id == UART_IIR_IID_THRI) {
    tx_provide();
  }

  return 0;
}

export fun notified(1 ch)
{
  var irq_ch = IRQ_CH;
  if (ch == irq_ch) {
    handle_irq();
    microkit_deferred_irq_ack(ch)
    return 0;
  }
  
  var tx_ch = TX_CH;
  if (ch == tx_ch) {
    tx_provide();
    return 0;
  }
  
  var rx_ch = RX_CH;
  if (ch == rx_ch) {
    rx_return();
    return 0;
  }
  
  return 0;
}
