/*
 * Copyright 2025, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */
#define IRQ_CH                      pnk_mem(1)
#define RX_CH                       pnk_mem(2)
#define TX_CH                       pnk_mem(3)

#define NET_RX_FREE                 pnk_mem(4)
#define NET_RX_ACTIVE               pnk_mem(5)
#define NET_RX_CAPACITY             pnk_mem(6)
#define NET_TX_FREE                 pnk_mem(7)
#define NET_TX_ACTIVE               pnk_mem(8)
#define NET_TX_CAPACITY             pnk_mem(9)

#define HW_RX_TAIL_SLOT             pnk_mem_ptr(10)
#define HW_RX_HEAD_SLOT             pnk_mem_ptr(11)
#define HW_RX_TAIL                  pnk_mem(10)
#define HW_RX_HEAD                  pnk_mem(11)
#define HW_RX_CAPACITY              pnk_mem(12)
#define HW_RX_DESCR                 pnk_mem(13)
#define HW_RX_PTR                   pnk_mem_ptr(10)

#define HW_TX_TAIL_SLOT             pnk_mem_ptr(14)
#define HW_TX_HEAD_SLOT             pnk_mem_ptr(15)
#define HW_TX_TAIL                  pnk_mem(14)
#define HW_TX_HEAD                  pnk_mem(15)
#define HW_TX_CAPACITY              pnk_mem(16)
#define HW_TX_DESCR                 pnk_mem(17)
#define HW_TX_PTR                   pnk_mem_ptr(14)

#define DMA_REG_OFFSET              4096

#define MAX_RX_FRAME_SZ             1536

#define DMA_INTR_TXF                1
#define DMA_INTR_RXF                64
#define DMA_INTR_FBE                8192
#define DMA_INTR_ABNORMAL           32768
#define DMA_INTR_MASK               106561

#define POLL_DATA                   4294967295

#define DESC_RXSTS_OWNBYDMA         2147483648
#define DESC_RXSTS_ERROR            32768
#define DESC_RXSTS_LENMSK           1073676288
#define DESC_RXSTS_LENSHFT          16

#define DESC_TXSTS_OWNBYDMA         2147483648

/* Descriptor control bits */
#define DESC_RXCTRL_SIZE1MASK       2047
#define DESC_RXCTRL_SIZE1SHFT       0
#define DESC_RXCTRL_RXRINGEND       33554432

#define DESC_TXCTRL_SIZE1MASK       2047
#define DESC_TXCTRL_SIZE1SHFT       0
#define DESC_TXCTRL_TXLAST          1073741824
#define DESC_TXCTRL_TXFIRST         536870912
#define DESC_TXCTRL_TXINT           2147483648
#define DESC_TXCTRL_TXRINGEND       33554432

#define MAC_REG_BASE                pnk_mem(0)

#define DMA_STATUS_OFFSET           20
#define DMA_RXPOLLDEMAND_OFFSET     8
#define DMA_TXPOLLDEMAND_OFFSET     4

#define DESCR_SIZE                  16
#define NET_BUFF_DESC_SIZE          16
#define MAX_INT16                   65535

var 1 irq_ch          = IRQ_CH;
var 1 rx_ch           = RX_CH;
var 1 tx_ch           = TX_CH;
var 1 mac_reg_base    = MAC_REG_BASE;
var 1 net_rx_free     = NET_RX_FREE;
var 1 net_rx_active   = NET_RX_ACTIVE;
var 1 net_rx_capacity = NET_RX_CAPACITY;
var 1 net_tx_free     = NET_TX_FREE;
var 1 net_tx_active   = NET_TX_ACTIVE;
var 1 net_tx_capacity = NET_TX_CAPACITY;
var 1 hw_rx_capacity  = HW_RX_CAPACITY;
var 1 hw_tx_capacity  = HW_TX_CAPACITY;
var 1 hw_rx_descr     = HW_RX_DESCR;
var 1 hw_tx_descr     = HW_TX_DESCR;

#define RX_HW_RING_EMPTY() (HW_RX_HEAD == HW_RX_TAIL)
#define TX_HW_RING_EMPTY() (HW_TX_HEAD == HW_TX_TAIL)
#define RX_HW_RING_FULL() ((HW_RX_TAIL - HW_RX_HEAD) == hw_rx_capacity)
#define TX_HW_RING_FULL() ((HW_TX_TAIL - HW_TX_HEAD) == hw_tx_capacity)

#define GET_DMA_STATUS(status_out) \
  var gds_reg_addr = mac_reg + DMA_REG_OFFSET + DMA_STATUS_OFFSET; \
  var gds_status = 0; \
  !ld32 gds_status, gds_reg_addr; \
  status_out = gds_status

#define SET_DMA_STATUS(status) \
  var sds_reg_addr = mac_reg + DMA_REG_OFFSET + DMA_STATUS_OFFSET; \
  !st32 sds_reg_addr, status

#define SET_RX_POLL() \
  var srp_reg_addr = mac_reg + DMA_REG_OFFSET + DMA_RXPOLLDEMAND_OFFSET; \
  !st32 srp_reg_addr, POLL_DATA

#define SET_TX_POLL() \
  var stp_reg_addr = mac_reg + DMA_REG_OFFSET + DMA_TXPOLLDEMAND_OFFSET; \
  !st32 stp_reg_addr, POLL_DATA

#define RX_UPDATE_RING_SLOT(ring_addr, idx, status, cntl, phys, next) \
  var rx_descr_base = hw_rx_descr; \
  var rx_descr = rx_descr_base + idx * DESCR_SIZE; \
  !st32 rx_descr + 8, phys; \
  !st32 rx_descr + 12, next; \
  !st32 rx_descr + 4, cntl; \
  !st32 rx_descr, status

#define TX_UPDATE_RING_SLOT(ring_addr, idx, status, cntl, phys, next) \
  var tx_descr_base = hw_tx_descr; \
  var tx_descr = tx_descr_base + idx * DESCR_SIZE; \
  !st32 tx_descr + 8, phys; \
  !st32 tx_descr + 12, next; \
  !st32 tx_descr + 4, cntl; \
  !st32 tx_descr, status

#define NET_QUEUE_EMPTY(queue_ptr, capacity, result_out) \
  var qe_tail = 0; \
  var qe_head = 0; \
  !ld16 qe_tail, queue_ptr; \
  !ld16 qe_head, queue_ptr + 2; \
  var qe_empty_check = qe_tail - qe_head; \
  result_out = (qe_empty_check == 0)

#define NET_DEQUEUE(queue_ptr, capacity, io_out, len_out) \
  var dq_head = 0; \
  !ld16 dq_head, queue_ptr + 2; \
  var dq_mod_head = dq_head & (capacity - 1); \
  var dq_entry_addr = queue_ptr + 8 + dq_mod_head * NET_BUFF_DESC_SIZE; \
  !ldw io_out, dq_entry_addr; \
  !ld32 len_out, dq_entry_addr + 8; \
  dq_head = (dq_head + 1) & MAX_INT16; \
  !st16 queue_ptr + 2, dq_head

#define NET_ENQUEUE(queue_ptr, io_addr, len, capacity) \
  var eq_tail = 0; \
  !ld16 eq_tail, queue_ptr; \
  var eq_mod_tail = eq_tail & (capacity - 1); \
  var eq_entry_addr = queue_ptr + 8 + eq_mod_tail * NET_BUFF_DESC_SIZE; \
  !stw eq_entry_addr, io_addr; \
  !st32 eq_entry_addr + 8, len; \
  eq_tail = (eq_tail + 1) & MAX_INT16; \
  !st16 queue_ptr, eq_tail

#define NET_REQUEST_SIGNAL(queue_ptr) \
  !st32 queue_ptr + 4, 0

#define NET_CANCEL_SIGNAL(queue_ptr) \
  !st32 queue_ptr + 4, 1

#define NET_REQUIRE_SIGNAL(queue_ptr, result_out) \
  var rs_signalled = 0; \
  !ld32 rs_signalled, queue_ptr + 4; \
  result_out = !rs_signalled

fun rx_provide()
{
  var reprocess = true;
  var rx_free = net_rx_free;
  var rx_queue_cap = net_rx_capacity;
  var hw_rx_capacity = hw_rx_capacity;
  var hw_rx_descr = hw_rx_descr;
  var mac_reg = mac_reg_base;

  while (reprocess)
  {
    while (true)
    {
      var full = RX_HW_RING_FULL();
      if (full) { break; }

      var empty = 0;
      NET_QUEUE_EMPTY(rx_free, rx_queue_cap, empty);
      if (empty) { break; }

      var io_addr = 0;
      var len = 0;
      NET_DEQUEUE(rx_free, rx_queue_cap, io_addr, len);

      var rx_tail = HW_RX_TAIL;
      var idx = rx_tail & (hw_rx_capacity - 1);

      var cntl = (MAX_RX_FRAME_SZ << DESC_RXCTRL_SIZE1SHFT) & DESC_RXCTRL_SIZE1MASK;
      if (idx + 1 == hw_rx_capacity) {
        cntl = cntl | DESC_RXCTRL_RXRINGEND;
      }
      RX_UPDATE_RING_SLOT(HW_RX_PTR, idx, DESC_RXSTS_OWNBYDMA, cntl, io_addr, 0);

      st HW_RX_TAIL_SLOT, (rx_tail + 1);
      SET_RX_POLL();
    }

    NET_REQUEST_SIGNAL(rx_free);
    reprocess = false;

    var empty = 0;
    NET_QUEUE_EMPTY(rx_free, rx_queue_cap, empty);
    var full = RX_HW_RING_FULL();
    if ((!empty) && (!full)) {
      NET_CANCEL_SIGNAL(rx_free);
      reprocess = true;
    }
  }
  return 0;
}

fun tx_provide()
{
  var reprocess = true;
  var tx_active = net_tx_active;
  var tx_queue_cap = net_tx_capacity;
  var hw_tx_capacity = hw_tx_capacity;
  var hw_tx_descr = hw_tx_descr;
  var mac_reg = mac_reg_base;

  while (reprocess)
  {
    while (true)
    {
      var full = TX_HW_RING_FULL();
      if (full) { break; }

      var empty = 0;
      NET_QUEUE_EMPTY(tx_active, tx_queue_cap, empty);
      if (empty) { break; }

      var io_addr = 0;
      var len = 0;
      NET_DEQUEUE(tx_active, tx_queue_cap, io_addr, len);

      var tx_tail = HW_TX_TAIL;
      var idx = tx_tail & (hw_tx_capacity - 1);

      var cntl = (len << DESC_TXCTRL_SIZE1SHFT) & DESC_TXCTRL_SIZE1MASK;
      cntl = cntl | DESC_TXCTRL_TXLAST | DESC_TXCTRL_TXFIRST | DESC_TXCTRL_TXINT;
      if (idx + 1 == hw_tx_capacity) {
        cntl = cntl | DESC_TXCTRL_TXRINGEND;
      }
      TX_UPDATE_RING_SLOT(HW_TX_PTR, idx, DESC_TXSTS_OWNBYDMA, cntl, io_addr, 0);

      st HW_TX_TAIL_SLOT, (tx_tail + 1);
    }

    NET_REQUEST_SIGNAL(tx_active);
    reprocess = false;

    var full = TX_HW_RING_FULL();
    var empty = 0;
    NET_QUEUE_EMPTY(tx_active, tx_queue_cap, empty);
    if ((!empty) && (!full)) {
      NET_CANCEL_SIGNAL(tx_active);
      reprocess = true;
    }
  }
  SET_TX_POLL();
  return 0;
}

fun rx_return()
{
  var rx_active = net_rx_active;
  var hw_rx_descr = hw_rx_descr;
  var rx_queue_cap = net_rx_capacity;
  var hw_rx_capacity = hw_rx_capacity;
  var mac_reg = mac_reg_base;

  var packets_transferred = false;

  while (true)
  {
    var empty = RX_HW_RING_EMPTY();
    if (empty) { break; }

    var rx_head = HW_RX_HEAD;
    var idx = rx_head & (hw_rx_capacity - 1);

    var dscr_addr = hw_rx_descr + idx * DESCR_SIZE;
    var status = 0;
    !ld32 status, dscr_addr;
    if (status & DESC_RXSTS_OWNBYDMA) { break; }

    if (status & DESC_RXSTS_ERROR) {
      var rx_tail = HW_RX_TAIL;
      var next_idx = rx_tail & (hw_rx_capacity - 1);
      var phys = 0;
      !ld32 phys, dscr_addr + 8;
      var cntl = (MAX_RX_FRAME_SZ << DESC_RXCTRL_SIZE1SHFT) & DESC_RXCTRL_SIZE1MASK;
      if (next_idx + 1 == hw_rx_capacity) {
        cntl = cntl | DESC_RXCTRL_RXRINGEND;
      }
      RX_UPDATE_RING_SLOT(HW_RX_PTR, next_idx, DESC_RXSTS_OWNBYDMA, cntl, phys, 0);
      st HW_RX_TAIL_SLOT, (rx_tail + 1);
      SET_RX_POLL();
    } else {
      var len = (status & DESC_RXSTS_LENMSK) >> DESC_RXSTS_LENSHFT;
      var io_addr = 0;
      !ld32 io_addr, dscr_addr + 8;
      NET_ENQUEUE(rx_active, io_addr, len, rx_queue_cap);
      packets_transferred = true;
    }
    st HW_RX_HEAD_SLOT, (rx_head + 1);
  }

  var to_signal = 0;
  NET_REQUIRE_SIGNAL(rx_active, to_signal);
  if (packets_transferred && to_signal) {
    NET_CANCEL_SIGNAL(rx_active);
    microkit_notify(rx_ch)
  }

  return 0;
}

fun tx_return()
{
  var tx_free = net_tx_free;
  var hw_tx_descr = hw_tx_descr;
  var tx_queue_cap = net_tx_capacity;
  var hw_tx_capacity = hw_tx_capacity;

  var enqueued = false;

  while (true)
  {
    var empty = TX_HW_RING_EMPTY();
    if (empty) { break; }

    var tx_head = HW_TX_HEAD;
    var idx = tx_head & (hw_tx_capacity - 1);

    var dscr_addr = hw_tx_descr + idx * DESCR_SIZE;
    var status = 0;
    !ld32 status, dscr_addr;
    if (status & DESC_TXSTS_OWNBYDMA) { break; }

    var io_addr = 0;
    !ld32 io_addr, dscr_addr + 8;
    NET_ENQUEUE(tx_free, io_addr, 0, tx_queue_cap);

    enqueued = true;
    st HW_TX_HEAD_SLOT, (tx_head + 1);
  }

  var to_signal = 0;
  NET_REQUIRE_SIGNAL(tx_free, to_signal);
  if (enqueued && to_signal) {
    NET_CANCEL_SIGNAL(tx_free);
    microkit_notify(tx_ch)
  }

  return 0;
}

fun main() {
  rx_provide();
  tx_provide();
  sddf_irq_ack(irq_ch)
  return 0;
}

fun handle_irq() {
  var mac_reg = mac_reg_base;
  var e = 0;
  GET_DMA_STATUS(e);
  SET_DMA_STATUS(e);

  while (e & DMA_INTR_MASK)
  {
    if (e & DMA_INTR_TXF) {
      tx_return();
      tx_provide();
    }
    if (e & DMA_INTR_RXF) {
      rx_return();
    }
    if (e & DMA_INTR_ABNORMAL) {
      if (e & DMA_INTR_FBE) {
          // error
      }
    }
    GET_DMA_STATUS(e);
    SET_DMA_STATUS(e);
  }
  return 0;
}

export fun notified(1 ch)
{
  if (ch == irq_ch) {
    handle_irq();
    microkit_deferred_irq_ack(ch)
    return 0;
  }
  if (ch == rx_ch) {
    rx_provide();
    return 0;
  }
  if (ch == tx_ch) {
    tx_provide();
    return 0;
  }

  return 0;
}
