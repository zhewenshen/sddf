#define ETH_REGS                        pnk_mem(0)

#define IRQ_CH                          pnk_mem(1)
#define RX_CH                           pnk_mem(2)
#define TX_CH                           pnk_mem(3)

#define NET_RX_FREE                     pnk_mem(4)
#define NET_RX_ACTIVE                   pnk_mem(5)
#define NET_RX_CAPACITY                 pnk_mem(6)
#define NET_TX_FREE                     pnk_mem(7)
#define NET_TX_ACTIVE                   pnk_mem(8)
#define NET_TX_CAPACITY                 pnk_mem(9)

#define HW_RX_PTR                       pnk_mem_ptr(10)
#define HW_RX_TAIL_SLOT                 pnk_mem_ptr(10)
#define HW_RX_HEAD_SLOT                 pnk_mem_ptr(11)
#define HW_RX_TAIL                      pnk_mem(10)
#define HW_RX_HEAD                      pnk_mem(11)
#define HW_RX_CAPACITY                  pnk_mem(12)
#define HW_RX_DESCR                     pnk_mem(13)
#define HW_RX_META                      pnk_mem_ptr(14)

#define HW_TX_PTR                       pnk_mem_ptr(270)
#define HW_TX_TAIL_SLOT                 pnk_mem_ptr(270)
#define HW_TX_HEAD_SLOT                 pnk_mem_ptr(271)
#define HW_TX_TAIL                      pnk_mem(270)
#define HW_TX_HEAD                      pnk_mem(271)
#define HW_TX_CAPACITY                  pnk_mem(272)
#define HW_TX_DESCR                     pnk_mem(273)
#define HW_TX_META                      pnk_mem_ptr(274)

#define RX_DESC_BASE                    pnk_mem(530)
#define TX_DESC_BASE                    pnk_mem(531)

#define DMA_CH0_STATUS                  4448
#define DMA_CH0_RXDESC_TAIL_PTR         4392

#define DESC_RXSTS_OWNBYDMA             2147483648      // BIT(31) - Owned by DMA
#define DESC_RXSTS_BUFFER1_ADDR_VALID   16777216        // BIT(24) - Buffer 1 address valid
#define DESC_RXSTS_IOC                  1073741824      // BIT(30) - Interrupt on completion
#define DESC_RXSTS_ERROR                32768           // BIT(15) - Error Summary
#define RX_LENGTH_MASK                  32767           // 0x7FFF - Mask for packet length in des3

#define DMA_CH0_INTERRUPT_EN_TIE        1               // BIT(0) - Transmit interrupt enable
#define DMA_CH0_INTERRUPT_EN_RIE        64              // BIT(6) - Receive interrupt enable
#define DMA_CH0_INTERRUPT_EN_FBEE       4096            // BIT(12) - Fatal bus error enable
#define DMA_CH0_INTERRUPT_EN_AIE        16384           // BIT(14) - Abnormal interrupt summary
#define DMA_CH0_INTERRUPT_EN_NIE        32768           // BIT(15) - Normal interrupt summary

#define DMA_INTR_NORMAL                 32833           // TIE | RIE | NIE = 1 | 64 | 32768
#define DMA_INTR_ABNORMAL               20480           // FBEE | AIE = 4096 | 16384
#define DMA_INTR_MASK                   53313           // NORMAL | ABNORMAL = 32833 | 20480

#define DESC_TXSTS_OWNBYDMA             2147483648      // BIT(31) - Owned by DMA
#define DESC_TXCTRL_TXINT               2147483648      // BIT(31) - Transmit interrupt after frame
#define DESC_TXCTRL_TXFIRST             536870912       // BIT(29) - First segment of frame
#define DESC_TXCTRL_TXLAST              268435456       // BIT(28) - Last segment of frame
#define DESC_TXCTRL_TXCIC               196608          // (3 << 16) - Checksum insertion

#define DMA_CH0_TXDESC_TAIL_PTR         4384            // 0x1120 - TX descriptor tail pointer

// globals
var 1 irq_ch           = IRQ_CH;
var 1 rx_ch            = RX_CH;
var 1 tx_ch            = TX_CH;
var 1 eth_regs         = ETH_REGS;
var 1 net_rx_free      = NET_RX_FREE;
var 1 net_rx_active    = NET_RX_ACTIVE;
var 1 net_rx_capacity  = NET_RX_CAPACITY;
var 1 net_tx_free      = NET_TX_FREE;
var 1 net_tx_active    = NET_TX_ACTIVE;
var 1 net_tx_capacity  = NET_TX_CAPACITY;
var 1 hw_rx_capacity   = HW_RX_CAPACITY;
var 1 hw_tx_capacity   = HW_TX_CAPACITY;
var 1 hw_rx_descr      = HW_RX_DESCR;
var 1 hw_tx_descr      = HW_TX_DESCR;
var 1 hw_rx_meta       = HW_RX_META;
var 1 hw_tx_meta       = HW_TX_META;
var 1 rx_desc_base     = RX_DESC_BASE;
var 1 tx_desc_base     = TX_DESC_BASE;

fun rx_hw_ring_empty() {
  var ret = (HW_RX_HEAD == HW_RX_TAIL);
  return ret;
}

fun tx_hw_ring_empty() {
  var ret = (HW_TX_HEAD == HW_TX_TAIL);
  return ret;
}

fun rx_hw_ring_full() {
  var ret = (HW_RX_TAIL - HW_RX_HEAD) == hw_rx_capacity;
  return ret;
}

fun tx_hw_ring_full() {
  var ret = (HW_TX_TAIL - HW_TX_HEAD) == hw_tx_capacity;
  return ret;
}

fun get_dma_reg(1 offset) {
  var reg_addr = eth_regs + offset;
  var val = 0;
  !ld32 val, reg_addr;
  return val;
}

fun set_dma_reg(1 offset, 1 value) {
  var reg_addr = eth_regs + offset;
  !st32 reg_addr, value;
  return 0;
}

fun rx_update_ring_slot(1 idx, 1 addr_low, 1 addr_high, 1 des2, 1 des3) {
  var descr = hw_rx_descr + idx * 16;

  !st32 descr, addr_low;
  !st32 descr + 4, addr_high;
  !st32 descr + 8, des2;
  THREAD_MEMORY_RELEASE()
  !st32 descr + 12, des3;
  return 0;
}

fun tx_update_ring_slot(1 idx, 1 addr_low, 1 addr_high, 1 des2, 1 des3) {
  var descr = hw_tx_descr + idx * 16;

  !st32 descr, addr_low;
  !st32 descr + 4, addr_high;
  !st32 descr + 8, des2;
  THREAD_MEMORY_RELEASE()
  !st32 descr + 12, des3;
  return 0;
}

fun rx_provide() {

  var reprocess = true;

  while (reprocess) {
    while (true) {
      var 1 full = rx_hw_ring_full();
      if (full) {
        break;
      }

      var 1 empty = net_queue_empty(net_rx_free, net_rx_capacity);
      if (empty) {
        break;
      }

      var {1,1} buffer = net_dequeue(net_rx_free, net_rx_capacity);
      var io_addr = buffer.0;

      var rx_tail = HW_RX_TAIL;
      // var idx = rx_tail & (hw_rx_capacity - 1);
      var idx = rx_tail;
      idx = idx & (hw_rx_capacity - 1); 

      st hw_rx_meta + idx * @biw, io_addr;

      rx_update_ring_slot(idx, io_addr, io_addr >> 32, 0, DESC_RXSTS_OWNBYDMA | DESC_RXSTS_BUFFER1_ADDR_VALID | DESC_RXSTS_IOC);
      THREAD_MEMORY_RELEASE()

      var tail_ptr = rx_desc_base + rx_tail * 16;
      set_dma_reg(DMA_CH0_RXDESC_TAIL_PTR, tail_ptr);

      st HW_RX_TAIL_SLOT, rx_tail + 1;
    }

    net_request_signal(net_rx_free, net_rx_capacity);
    reprocess = false;

    var 1 empty_after = net_queue_empty(net_rx_free, net_rx_capacity);
    var 1 full_after = rx_hw_ring_full();
    if ((!empty_after) && (!full_after)) {
      net_cancel_signal(net_rx_free);
      reprocess = true;
    }
  }
  return 0;
}

fun rx_return() {
  var packets_transferred = false;
  while (true) {
    var 1 empty = rx_hw_ring_empty();
    if (empty) {
      break;
    }

    var rx_head = HW_RX_HEAD;
    var idx = rx_head & (hw_rx_capacity - 1);
    var idx = rx_head;
    // while (idx >= HW_RX_CAPACITY) {
    //   idx = idx - HW_RX_CAPACITY;
    // }
    // idx = rx_head;
    idx = idx & 255;

    // debug_print(0,rx_head,0,1111);
    // debug_print(0,idx,0,2222);
    // debug_print(0, idx, 0, 0987654321);
    
    var descr = hw_rx_descr + idx * 16;
    var des3 = 0;
    !ld32 des3, descr + 12;
    if (des3 & DESC_RXSTS_OWNBYDMA) { break; }

    THREAD_MEMORY_ACQUIRE()

    var io_addr = lds 1 (hw_rx_meta + idx * @biw);

    if (des3 & DESC_RXSTS_ERROR) {
      debug_print(0,1234567890, 0, 1234567890);
      var rx_tail = HW_RX_TAIL;
      var error_idx = rx_tail & (hw_rx_capacity - 1);

      st hw_rx_meta + error_idx * @biw, io_addr;
      rx_update_ring_slot(error_idx, io_addr, io_addr >> 32, 0, DESC_RXSTS_OWNBYDMA | DESC_RXSTS_BUFFER1_ADDR_VALID | DESC_RXSTS_IOC);
      var tail_ptr = rx_desc_base + error_idx * 16;
      set_dma_reg(DMA_CH0_RXDESC_TAIL_PTR, tail_ptr);
      st HW_RX_TAIL_SLOT, (rx_tail + 1);
    } else {
      var len = des3 & RX_LENGTH_MASK;
      net_enqueue(net_rx_active, io_addr, len, net_rx_capacity);
      packets_transferred = true;
    }

    st HW_RX_HEAD_SLOT, rx_head + 1;
  }

  var 1 to_signal = net_require_signal(net_rx_active, net_rx_capacity);

  if (packets_transferred && to_signal) {
      net_cancel_signal(net_rx_active);
      microkit_notify(rx_ch)
  }

  return 0;
}

fun tx_provide() {
  var reprocess = true;

  while (reprocess) {
    while (true) {
      var 1 full = tx_hw_ring_full();
      if (full) { break; }

      var 1 empty = net_queue_empty(net_tx_active, net_tx_capacity);
      if (empty) { break; }

      var {1,1} buffer = net_dequeue(net_tx_active, net_tx_capacity);
      var io_addr = buffer.0;
      var len = buffer.1;

      var des2 = DESC_TXCTRL_TXINT | len;

      var tx_tail = HW_TX_TAIL;
      var idx = tx_tail & (hw_tx_capacity - 1);

      st hw_tx_meta + idx * @biw, io_addr;
      
      var addr_low = io_addr;
      var addr_high = io_addr >> 32;

      var des3 = DESC_TXSTS_OWNBYDMA | DESC_TXCTRL_TXFIRST | DESC_TXCTRL_TXLAST | DESC_TXCTRL_TXCIC | len;

      tx_update_ring_slot(idx, addr_low, addr_high, des2, des3);

      st HW_TX_TAIL_SLOT, (tx_tail + 1);

      var tail_addr = tx_desc_base + 16 * idx;
      set_dma_reg(DMA_CH0_TXDESC_TAIL_PTR, tail_addr);
    }

    net_request_signal(net_tx_active, net_tx_capacity);
    reprocess = false;

    var 1 full_after = tx_hw_ring_full();
    var 1 empty_after = net_queue_empty(net_tx_active, net_tx_capacity);
    if ((!full_after) && (!empty_after)) {
      net_cancel_signal(net_tx_active);
      reprocess = true;
    }
  }
  return 0;
}

fun tx_return() {
  var enqueued = false;

  while (true) {
    var 1 empty = tx_hw_ring_empty();
    if (empty) { break; }

    var tx_head = HW_TX_HEAD;
    var idx = tx_head & (hw_tx_capacity - 1);

    var descr = hw_tx_descr + idx * 16;
    var des3 = 0;
    !ld32 des3, descr + 12;

    if (des3 & DESC_TXSTS_OWNBYDMA) { break; }

    THREAD_MEMORY_ACQUIRE()

    var io_addr = lds 1 (hw_tx_meta + idx * @biw);  // tx->io_addr_mdata[idx]

    net_enqueue(net_tx_free, io_addr, 0, net_tx_capacity);

    enqueued = true;

    st HW_TX_HEAD_SLOT, (tx_head + 1);
  }

  if (enqueued) {
    var 1 to_signal = net_require_signal(net_tx_free, net_tx_capacity);
    if (to_signal) {
      net_cancel_signal(net_tx_free);
      microkit_notify(tx_ch)
    }
  }

  return 0;
}

fun main() {
  rx_provide();
  tx_provide();

  return 0;
}

fun handle_irq_set_dma(1 ee) {
  var 1 e = get_dma_reg(DMA_CH0_STATUS);
  e = e & ee;
  set_dma_reg(DMA_CH0_STATUS, e & e);

  return 0;
}

fun handle_irq() {
  var 1 e = get_dma_reg(DMA_CH0_STATUS);
  handle_irq_set_dma(e);

  while (e & DMA_INTR_MASK) {
    if (e & DMA_CH0_INTERRUPT_EN_TIE) {
      // @tx_return(0,0,0,0);
      // @tx_provide(0,0,0,0);
      tx_return();
      tx_provide();
    }

    if (e & DMA_CH0_INTERRUPT_EN_RIE) {
      // @rx_return(0,0,0,0);
      rx_return();
    }

    if (e & DMA_INTR_ABNORMAL) {
      if (e & DMA_CH0_INTERRUPT_EN_FBEE) {
        debug_print(0,911,0,911);
        @assert(0,0,0,0);
      }
    }

    e = get_dma_reg(DMA_CH0_STATUS);
    handle_irq_set_dma(e);
  }

  return 0;
}

export fun notified(1 ch) {
  if (ch == irq_ch) {
    handle_irq();
    microkit_deferred_irq_ack(irq_ch)
  }

  if (ch == rx_ch) {
    rx_provide();
  }

  if (ch == tx_ch) {
    tx_provide();
  }

  if ((ch != irq_ch) && (ch != tx_ch) && (ch != rx_ch)) {
    debug_print(0,ch,0,56789);
    // @dump_pnk_mem_slots(0,0,0,0);
    // @assert(0,0,0,0);
  }

  return 0;
}
