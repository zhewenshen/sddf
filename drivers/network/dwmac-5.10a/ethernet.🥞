#define ETH_REGS pnk_mem(0)

#define IRQ_CH pnk_mem(1)
#define RX_CH pnk_mem(2)
#define TX_CH pnk_mem(3)

#define NET_RX_FREE     pnk_mem(4)
#define NET_RX_ACTIVE   pnk_mem(5)
#define NET_RX_CAPACITY pnk_mem(6)
#define NET_TX_FREE     pnk_mem(7)
#define NET_TX_ACTIVE   pnk_mem(8)
#define NET_TX_CAPACITY pnk_mem(9)

#define HW_RX_PTR       pnk_mem_ptr(10)
#define HW_RX_TAIL_SLOT pnk_mem_ptr(10)
#define HW_RX_HEAD_SLOT pnk_mem_ptr(11)
#define HW_RX_TAIL      pnk_mem(10)
#define HW_RX_HEAD      pnk_mem(11)
#define HW_RX_CAPACITY  pnk_mem(12)
#define HW_RX_DESCR     pnk_mem(13)
#define HW_RX_META      pnk_mem_ptr(14)

#define HW_TX_PTR       pnk_mem_ptr(270)
#define HW_TX_TAIL_SLOT pnk_mem_ptr(270)
#define HW_TX_HEAD_SLOT pnk_mem_ptr(271)
#define HW_TX_TAIL      pnk_mem(270)
#define HW_TX_HEAD      pnk_mem(271)
#define HW_TX_CAPACITY  pnk_mem(272)
#define HW_TX_DESCR     pnk_mem(273)
#define HW_TX_META      pnk_mem_ptr(274)

#define RX_DESC_BASE    pnk_mem(530)
#define TX_DESC_BASE    pnk_mem(531)

#define DMA_CH0_STATUS 4448
#define DMA_CH0_RXDESC_TAIL_PTR 4392

#define DESC_RXSTS_OWNBYDMA 2147483648          // BIT(31) - Owned by DMA
#define DESC_RXSTS_BUFFER1_ADDR_VALID 16777216  // BIT(24) - Buffer 1 address valid
#define DESC_RXSTS_IOC 1073741824               // BIT(30) - Interrupt on completion
#define DESC_RXSTS_ERROR 32768                  // BIT(15) - Error Summary
#define RX_LENGTH_MASK 32767                    // 0x7FFF - Mask for packet length in des3

#define DMA_CH0_INTERRUPT_EN_TIE 1              // BIT(0) - Transmit interrupt enable
#define DMA_CH0_INTERRUPT_EN_RIE 64             // BIT(6) - Receive interrupt enable
#define DMA_CH0_INTERRUPT_EN_FBEE 4096          // BIT(12) - Fatal bus error enable
#define DMA_CH0_INTERRUPT_EN_AIE 16384          // BIT(14) - Abnormal interrupt summary
#define DMA_CH0_INTERRUPT_EN_NIE 32768          // BIT(15) - Normal interrupt summary

#define DMA_INTR_NORMAL 32833                   // TIE | RIE | NIE = 1 | 64 | 32768
#define DMA_INTR_ABNORMAL 20480                 // FBEE | AIE = 4096 | 16384
#define DMA_INTR_MASK 53313                     // NORMAL | ABNORMAL = 32833 | 20480

#define DESC_TXSTS_OWNBYDMA 2147483648          // BIT(31) - Owned by DMA
#define DESC_TXCTRL_TXINT 2147483648            // BIT(31) - Transmit interrupt after frame
#define DESC_TXCTRL_TXFIRST 536870912           // BIT(29) - First segment of frame
#define DESC_TXCTRL_TXLAST 268435456            // BIT(28) - Last segment of frame
#define DESC_TXCTRL_TXCIC 196608                // (3 << 16) - Checksum insertion

#define DMA_CH0_TXDESC_TAIL_PTR 4384            // 0x1120 - TX descriptor tail pointer


fun rx_hw_ring_empty() {
  var tail = HW_RX_TAIL;
  var head = HW_RX_HEAD;

  var ret = (head == tail);
  return ret;
}

fun tx_hw_ring_empty() {
  var tail = HW_TX_TAIL;
  var head = HW_TX_HEAD;

  var ret = (head == tail);
  return ret;
}

fun rx_hw_ring_full() {
  var tail = HW_RX_TAIL;
  var head = HW_RX_HEAD;

  var ret = (tail - head) == HW_RX_CAPACITY;
  return ret;
}

fun tx_hw_ring_full() {
  var tail = HW_TX_TAIL;
  var head = HW_TX_HEAD;

  var ret = (tail - head) == HW_TX_CAPACITY;
  return ret;
}

fun get_dma_reg(1 offset) {
  var reg_addr = ETH_REGS + offset;
  var val = 0;
  !ld32 val, reg_addr;
  return val;
}

fun set_dma_reg(1 offset, 1 value) {
  var reg_addr = ETH_REGS + offset;
  !st32 reg_addr, value;
  return 0;
}

fun rx_update_ring_slot(1 idx, 1 addr_low, 1 addr_high, 1 des2, 1 des3) {
  var descr_base = HW_RX_DESCR;
  var descr = descr_base + idx * 16;

  !st32 descr, addr_low;
  !st32 descr + 4, addr_high;
  !st32 descr + 8, des2;
  THREAD_MEMORY_RELEASE()
  !st32 descr + 12, des3;
  return 0;
}

fun tx_update_ring_slot(1 idx, 1 addr_low, 1 addr_high, 1 des2, 1 des3) {
  var descr_base = HW_TX_DESCR;
  var descr = descr_base + idx * 16;

  !st32 descr, addr_low;
  !st32 descr + 4, addr_high;
  !st32 descr + 8, des2;
  THREAD_MEMORY_RELEASE()
  !st32 descr + 12, des3;
  return 0;
}

fun rx_provide() {
  var rx_free = NET_RX_FREE;
  var rx_queue_cap = NET_RX_CAPACITY;
  var rx_hw_cap = HW_RX_CAPACITY;
  var rx_io_mdata = HW_RX_META;

  var reprocess = true;

  while (reprocess) {
    while (true) {
      var 1 full = rx_hw_ring_full();
      if (full) {
        break;
      }

      var 1 empty = net_queue_empty(rx_free, rx_queue_cap);
      if (empty) {
        break;
      }

      var {1,1} buffer = net_dequeue(rx_free, rx_queue_cap);
      var io_addr = buffer.0;

      var rx_tail = HW_RX_TAIL;
      // var idx = HW_RX_TAIL & 255;
      var idx = 0;
      idx = rx_tail & 255;

      st rx_io_mdata + idx * @biw, io_addr;

      rx_update_ring_slot(idx, io_addr, io_addr >> 32, 0, DESC_RXSTS_OWNBYDMA | DESC_RXSTS_BUFFER1_ADDR_VALID | DESC_RXSTS_IOC);
      THREAD_MEMORY_RELEASE()

      var tail_ptr = RX_DESC_BASE + rx_tail * 16;
      set_dma_reg(DMA_CH0_RXDESC_TAIL_PTR, tail_ptr);

      st HW_RX_TAIL_SLOT, rx_tail + 1;
    }

    net_request_signal(rx_free, rx_queue_cap);
    reprocess = false;

    var 1 empty_after = net_queue_empty(rx_free, rx_queue_cap);
    var 1 full_after = rx_hw_ring_full();
    if ((!empty_after) && (!full_after)) {
      net_cancel_signal(rx_free);
      reprocess = true;
    }
  }
  return 0;
}

fun rx_return() {
  var rx_io_mdata = HW_RX_META;
  var packets_transferred = false;
  while (true) {
    var 1 empty = rx_hw_ring_empty();
    if (empty) {
      break;
    }

    var rx_head = HW_RX_HEAD;
    var rx_capacity = HW_RX_CAPACITY;
    var idx = 0;
    idx = rx_head & 255;

    // debug_print(0, idx, 0, 0987654321);

    var descr_base = HW_RX_DESCR;
    var descr = descr_base + idx * 16;
    var des3 = 0;
    !ld32 des3, descr + 12;

    if (des3 & DESC_RXSTS_OWNBYDMA) { break; }

    THREAD_MEMORY_ACQUIRE()

    var io_addr = lds 1 (rx_io_mdata + idx * @biw);

    if (des3 & DESC_RXSTS_ERROR) {
      debug_print(0,1234567890, 0, 1234567890);
      var rx_tail = HW_RX_TAIL;
      // var error_idx = rx_tail & (rx_capacity - 1);
      var error_idx = 0;
      error_idx = rx_tail & 255;
      st HW_RX_META + error_idx * @biw, io_addr;
      rx_update_ring_slot(error_idx, io_addr, io_addr >> 32, 0, DESC_RXSTS_OWNBYDMA | DESC_RXSTS_BUFFER1_ADDR_VALID | DESC_RXSTS_IOC);
      var tail_ptr = RX_DESC_BASE + error_idx * 16;
      set_dma_reg(DMA_CH0_RXDESC_TAIL_PTR, tail_ptr);
      st HW_RX_TAIL_SLOT, (rx_tail + 1);
    } else {
      var len = des3 & RX_LENGTH_MASK;
      net_enqueue(NET_RX_ACTIVE, io_addr, len, NET_RX_CAPACITY);
      packets_transferred = true;
    }

    st HW_RX_HEAD_SLOT, (rx_head + 1);
  }

  var 1 to_signal = net_require_signal(NET_RX_ACTIVE, NET_RX_CAPACITY);

  if (packets_transferred && to_signal) {
      net_cancel_signal(NET_RX_ACTIVE);
      microkit_notify(RX_CH)
  }

  return 0;
}

fun tx_provide() {
  var reprocess = true;

  while (reprocess) {
    while (true) {
      var 1 full = tx_hw_ring_full();
      if (full) { break; }

      var 1 empty = net_queue_empty(NET_TX_ACTIVE, NET_TX_CAPACITY);
      if (empty) { break; }

      var {1,1} buffer = net_dequeue(NET_TX_ACTIVE, NET_TX_CAPACITY);
      var io_addr = buffer.0;
      var len = buffer.1;

      var des2 = DESC_TXCTRL_TXINT | len;

      var tx_tail = HW_TX_TAIL;
      var tx_capacity = HW_TX_CAPACITY;
      // var idx = tx_tail & (tx_capacity - 1);
      var idx = 0;
      idx = tx_tail & 255;

      st HW_TX_META + idx * @biw, io_addr;
      
      var addr_low = io_addr;
      var addr_high = io_addr >> 32;

      var des3 = DESC_TXSTS_OWNBYDMA | DESC_TXCTRL_TXFIRST | DESC_TXCTRL_TXLAST | DESC_TXCTRL_TXCIC | len;

      tx_update_ring_slot(idx, addr_low, addr_high, des2, des3);

      st HW_TX_TAIL_SLOT, (tx_tail + 1);

      var tx_desc_base = TX_DESC_BASE;
      var tail_addr = tx_desc_base + 16 * idx;
      set_dma_reg(DMA_CH0_TXDESC_TAIL_PTR, tail_addr);
    }

    net_request_signal(NET_TX_ACTIVE, NET_TX_CAPACITY);
    reprocess = false;

    var 1 full_after = tx_hw_ring_full();
    var 1 empty_after = net_queue_empty(NET_TX_ACTIVE, NET_TX_CAPACITY);
    if ((!full_after) && (!empty_after)) {
      net_cancel_signal(NET_TX_ACTIVE);
      reprocess = true;
    }
  }
  return 0;
}

fun tx_return() {
  var enqueued = false;

  while (true) {
    var 1 empty = tx_hw_ring_empty();
    if (empty) { break; }

    var tx_head = HW_TX_HEAD;
    var tx_capacity = HW_TX_CAPACITY;
    var idx = tx_head & (tx_capacity - 1);

    var descr_base = HW_TX_DESCR;
    var descr = descr_base + idx * 16;
    var des3 = 0;
    !ld32 des3, descr + 12;

    if (des3 & DESC_TXSTS_OWNBYDMA) { break; }

    THREAD_MEMORY_ACQUIRE()

    var io_addr = lds 1 (HW_TX_META + idx * @biw);  // tx->io_addr_mdata[idx]

    net_enqueue(NET_TX_FREE, io_addr, 0, NET_TX_CAPACITY);

    enqueued = true;

    st HW_TX_HEAD_SLOT, (tx_head + 1);
  }

  if (enqueued) {
    var 1 to_signal = net_require_signal(NET_TX_FREE, NET_TX_CAPACITY);
    if (to_signal) {
      net_cancel_signal(NET_TX_FREE);
      microkit_notify(TX_CH)
    }
  }

  return 0;
}

fun main() {
  rx_provide();
  tx_provide();

  return 0;
}

fun handle_irq_set_dma(1 ee) {
  var 1 e = get_dma_reg(DMA_CH0_STATUS);
  e = e & ee;
  set_dma_reg(DMA_CH0_STATUS, e & e);

  return 0;
}

fun handle_irq() {
  var 1 e = get_dma_reg(DMA_CH0_STATUS);
  // set_dma_reg(DMA_CH0_STATUS, e & e);
  handle_irq_set_dma(e);

  while (e & DMA_INTR_MASK) {
    if (e & DMA_CH0_INTERRUPT_EN_TIE) {
      // @tx_return(0,0,0,0);
      // @tx_provide(0,0,0,0);
      tx_return();
      tx_provide();
    }

    if (e & DMA_CH0_INTERRUPT_EN_RIE) {
      // @rx_return(0,0,0,0);
      rx_return();
    }

    if (e & DMA_INTR_ABNORMAL) {
      if (e & DMA_CH0_INTERRUPT_EN_FBEE) {
        debug_print(0,911,0,911);
        @assert(0,0,0,0);
      }
    }

    e = get_dma_reg(DMA_CH0_STATUS);
    // set_dma_reg(DMA_CH0_STATUS, e & e);
    handle_irq_set_dma(e);
  }

  return 0;
}

export fun notified(1 ch) {
  var irq_ch = IRQ_CH;
  var rx_ch = RX_CH;
  var tx_ch = TX_CH;

  if (ch == irq_ch) {
    handle_irq();
    microkit_deferred_irq_ack(irq_ch)
    return 0;
  }

  if (ch == rx_ch) {
    rx_provide();
    return 0;
  }

  if (ch == tx_ch) {
    tx_provide();
    return 0;
  }

  if ((ch != irq_ch) && (ch != tx_ch) && (ch != rx_ch)) {
    debug_print(0,ch,0,56789);
    // @dump_pnk_mem_slots(0,0,0,0);
    // @assert(0,0,0,0);
  }

  return 0;
}
