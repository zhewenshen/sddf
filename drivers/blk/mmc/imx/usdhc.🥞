/*
 * Copyright 2025, UNSW
 * SPDX-License-Identifier: BSD-2-Clause
 */

/*
 * Pancake implementation of i.MX8 uSDHC (MMC/SD card) block driver
 *
 * This port handles the performance-critical paths:
 * - IRQ handling and interrupt status management
 * - Block queue request/response processing
 * - DMA setup and control
 * - Register access operations
 *
 * Complex state machines (card initialization, command protocols) remain in C.
 *
 * IMPORTANT NOTES:
 * - All numeric literals are in DECIMAL (Pancake doesn't support hex)
 * - Type annotations (var 1 x) only for function return values
 * - Regular variables use (var x) without type annotation
 */

/* ========== Memory Slot Definitions ========== */

/* Hardware and channel configuration */
/* uSDHC register base address */
#define USDHC_REG_BASE          pnk_mem(0)
/* IRQ channel ID */
#define IRQ_CH                  pnk_mem(1)
/* Virtualizer channel ID */
#define VIRT_CH                 pnk_mem(2)

/* Block queue handle (blk_queue_handle_t structure layout at slot 3) */
#define BLK_QUEUE_HANDLE_PTR    pnk_mem_ptr(3)
/* Pointer to request queue structure */
#define BLK_REQ_QUEUE_PTR       pnk_mem(3)
/* Pointer to response queue structure */
#define BLK_RESP_QUEUE_PTR      pnk_mem(4)
/* Queue capacity (num_buffers) */
#define BLK_QUEUE_CAPACITY      pnk_mem(5)

/* Driver state - minimal state for Pancake hot paths */
/* Boolean: request in flight */
#define BLK_REQ_INFLIGHT        pnk_mem(6)
/* Current request ID */
#define BLK_REQ_ID              pnk_mem(7)
/* Current request code */
#define BLK_REQ_CODE            pnk_mem(8)
/* Current request physical address */
#define BLK_REQ_PADDR           pnk_mem(9)
/* Current block number */
#define BLK_REQ_BLK_NUMBER      pnk_mem(10)
/* Current block count */
#define BLK_REQ_BLK_COUNT       pnk_mem(11)

/* Card state - Card Capacity Status (SDHC/SDXC vs SDSC) */
#define CARD_CCS                pnk_mem(12)

/* Driver status - DrvStatusInactive(0), DrvStatusBringup(1), DrvStatusActive(2) */
#define DRIVER_STATUS           pnk_mem(13)

/* ========== uSDHC Register Offsets (in DECIMAL) ========== */

/* DMA System Address */
#define USDHC_DS_ADDR_OFFSET            0
/* Block Attributes */
#define USDHC_BLK_ATT_OFFSET            4
/* Command Argument */
#define USDHC_CMD_ARG_OFFSET            8
/* Command Transfer Type */
#define USDHC_CMD_XFR_TYP_OFFSET        12
/* Command Response 0 */
#define USDHC_CMD_RSP0_OFFSET           16
/* Present State */
#define USDHC_PRES_STATE_OFFSET         36
/* System Control */
#define USDHC_SYS_CTRL_OFFSET           44
/* Interrupt Status */
#define USDHC_INT_STATUS_OFFSET         48
/* Interrupt Status Enable */
#define USDHC_INT_STATUS_EN_OFFSET      52
/* Interrupt Signal Enable */
#define USDHC_INT_SIGNAL_EN_OFFSET      56
/* Mixer Control */
#define USDHC_MIX_CTRL_OFFSET           72

/* ========== Register Bit Definitions (in DECIMAL) ========== */

/* Block Attributes Register - 0x00001FFF */
#define USDHC_BLK_ATT_BLKSIZE_MASK      8191
#define USDHC_BLK_ATT_BLKSIZE_SHIFT     0
/* 0xFFFF0000 */
#define USDHC_BLK_ATT_BLKCNT_MASK       4294901760
#define USDHC_BLK_ATT_BLKCNT_SHIFT      16

/* Interrupt Status Register */
/* 0x00000001 - Command Complete */
#define USDHC_INT_STATUS_CC             1
/* 0x00000002 - Transfer Complete */
#define USDHC_INT_STATUS_TC             2
/* 0x10000000 - DMA Error */
#define USDHC_INT_STATUS_DMAE           268435456

/* Error interrupt mask (all error bits 16-31, excluding CC and TC) - 0xFFFF0000 */
#define USDHC_INT_ERROR_MASK            4294901760

/* Mix Control Register */
/* 0x00000010 - Data Transfer Direction (1=read) */
#define USDHC_MIX_CTRL_DTDSEL           16
/* 0xFFFFFFEF - ~DTDSEL for clearing */
#define USDHC_MIX_CTRL_DTDSEL_INV       4294967279

/* ========== SD/MMC Constants ========== */

#define SD_BLOCK_SIZE                   512
/* BLK_TRANSFER_SIZE (2048) / SD_BLOCK_SIZE (512) */
#define SDDF_BLOCKS_TO_SD_BLOCKS        4

/* Block request codes */
#define BLK_REQ_READ                    0
#define BLK_REQ_WRITE                   1
#define BLK_REQ_FLUSH                   2
#define BLK_REQ_BARRIER                 3

/* Block response status codes */
#define BLK_RESP_OK                     0
#define BLK_RESP_ERR_UNSPEC             1
#define BLK_RESP_ERR_NO_DEVICE          2
#define BLK_RESP_ERR_INVALID_PARAM      3

/* Driver status values */
#define DRV_STATUS_INACTIVE             0
#define DRV_STATUS_BRINGUP              1
#define DRV_STATUS_ACTIVE               2

/* ========== Global Variables (loaded from memory slots) ========== */
/* Globals need shape annotations - use explicit lds syntax */

var 1 usdhc_reg_base    = (lds 1 (@base + (0) * @biw));
var 1 irq_ch            = (lds 1 (@base + (1) * @biw));
var 1 virt_ch           = (lds 1 (@base + (2) * @biw));
var 1 blk_req_queue_ptr = (lds 1 (@base + (3) * @biw));
var 1 blk_resp_queue_ptr = (lds 1 (@base + (4) * @biw));
var 1 blk_queue_capacity = (lds 1 (@base + (5) * @biw));

/* ========== Helper Functions: Register Access ========== */

fun read_reg32(1 offset) {
  var addr = usdhc_reg_base + offset;
  var value = 0;
  !ld32 value, addr;
  return value;
}

fun write_reg32(1 offset, 1 value) {
  var addr = usdhc_reg_base + offset;
  !st32 addr, value;
  return 0;
}

/* ========== Helper Functions: Interrupt Status ========== */

/*
 * Check if interrupt status indicates an error.
 * Returns: 1 if error, 0 if no error, MAX_INT32 if waiting for completion
 */
fun check_interrupt_status(1 has_data) {
  var 1 int_status = read_reg32(USDHC_INT_STATUS_OFFSET);

  /* Check for any error bits (bits 16-31, excluding CC and TC) */
  var error_bits = int_status & USDHC_INT_ERROR_MASK;
  if (error_bits != 0) {
    /* Clear all interrupt status bits - 0xFFFFFFFF */
    var 1 clear_result = write_reg32(USDHC_INT_STATUS_OFFSET, 4294967295);
    return 1;
  }

  /* Check for command complete */
  var cmd_complete = int_status & USDHC_INT_STATUS_CC;
  if (cmd_complete != 0) {
    /* Clear CC bit */
    var 1 clear_cc = write_reg32(USDHC_INT_STATUS_OFFSET, USDHC_INT_STATUS_CC);
  }

  /* Check for transfer complete (only for data transfers) */
  var transfer_complete = int_status & USDHC_INT_STATUS_TC;
  if (has_data != 0 && transfer_complete == 0) {
    /* Still waiting for transfer to complete */
    return MAX_INT32;
  }

  if (transfer_complete != 0) {
    /* Clear TC bit */
    var 1 clear_tc = write_reg32(USDHC_INT_STATUS_OFFSET, USDHC_INT_STATUS_TC);
  }

  return 0;
}

/* ========== Helper Functions: Block Queue Operations ========== */

/*
 * Queue structure layout (from sddf/blk/queue.h):
 * - head: uint32_t (offset 0, size 4)
 * - tail: uint32_t (offset 4, size 4)
 * - signal: uint32_t (offset 8, size 4)
 * - entries: array of blk_req_queue_entry_t or blk_resp_queue_entry_t
 *
 * Request entry (32 bytes):
 * - code: uint32_t (offset 0)
 * - (padding 4 bytes)
 * - paddr: uintptr_t (offset 8)
 * - block_number: uint64_t (offset 16)
 * - count: uint16_t (offset 24)
 * - (padding 2 bytes)
 * - id: uint32_t (offset 28)
 *
 * Response entry (16 bytes):
 * - status: uint32_t (offset 0)
 * - success_count: uint16_t (offset 4)
 * - (padding 2 bytes)
 * - id: uint32_t (offset 8)
 * - (padding 4 bytes)
 */

#define BLK_REQ_ENTRY_SIZE              32
#define BLK_RESP_ENTRY_SIZE             16
#define BLK_QUEUE_HEADER_SIZE           12

fun blk_queue_empty_req() {
  var req_queue = blk_req_queue_ptr;
  var head = 0;
  var tail = 0;
  !ld32 head, req_queue;
  !ld32 tail, req_queue + 4;
  var empty = (head == tail);
  return empty;
}

fun blk_dequeue_req() {
  var req_queue = blk_req_queue_ptr;
  var capacity = blk_queue_capacity;

  var head = 0;
  var tail = 0;
  !ld32 head, req_queue;
  !ld32 tail, req_queue + 4;

  if (head == tail) {
    return MAX_INT32;
  }

  /* Calculate entry address */
  var idx = head & (capacity - 1);
  var entry_addr = req_queue + BLK_QUEUE_HEADER_SIZE + idx * BLK_REQ_ENTRY_SIZE;

  /* Read request entry fields */
  var code = 0;
  var paddr = 0;
  var block_number = 0;
  var count = 0;
  var id = 0;

  !ld32 code, entry_addr;
  !ldw paddr, entry_addr + 8;
  !ldw block_number, entry_addr + 16;
  !ld16 count, entry_addr + 24;
  !ld32 id, entry_addr + 28;

  /* Update head pointer */
  var new_head = head + 1;
  !st32 req_queue, new_head;

  /* Store request info in driver state slots */
  st pnk_mem_ptr(8), code;
  st pnk_mem_ptr(9), paddr;
  st pnk_mem_ptr(10), block_number;
  st pnk_mem_ptr(11), count;
  st pnk_mem_ptr(7), id;

  return 0;
}

fun blk_enqueue_resp(1 status, 1 success_count) {
  var resp_queue = blk_resp_queue_ptr;
  var capacity = blk_queue_capacity;
  var id = BLK_REQ_ID;

  var head = 0;
  var tail = 0;
  !ld32 head, resp_queue;
  !ld32 tail, resp_queue + 4;

  /* Check if queue is full */
  var count = tail - head;
  if (count >= capacity) {
    return MAX_INT32;
  }

  /* Calculate entry address */
  var idx = tail & (capacity - 1);
  var entry_addr = resp_queue + BLK_QUEUE_HEADER_SIZE + idx * BLK_RESP_ENTRY_SIZE;

  /* Write response entry */
  !st32 entry_addr, status;
  !st16 entry_addr + 4, success_count;
  !st32 entry_addr + 8, id;

  /* Memory barrier before updating tail */
  THREAD_MEMORY_RELEASE()

  /* Update tail pointer */
  var new_tail = tail + 1;
  !st32 resp_queue + 4, new_tail;

  return 0;
}

/* ========== Helper Functions: DMA Setup ========== */

fun setup_read_dma(1 dma_addr, 1 sector_count) {
  var 1 write_dma = write_reg32(USDHC_DS_ADDR_OFFSET, dma_addr);

  var 1 blk_att = read_reg32(USDHC_BLK_ATT_OFFSET);
  /* Clear BLKSIZE (keep upper 16 bits) */
  blk_att = blk_att & 4294901760;
  blk_att = blk_att | SD_BLOCK_SIZE;
  /* Clear BLKCNT (keep lower 16 bits) */
  blk_att = blk_att & 65535;
  blk_att = blk_att | (sector_count << 16);
  var 1 write_blk = write_reg32(USDHC_BLK_ATT_OFFSET, blk_att);

  var 1 mix_ctrl = read_reg32(USDHC_MIX_CTRL_OFFSET);
  mix_ctrl = mix_ctrl | USDHC_MIX_CTRL_DTDSEL;
  var 1 write_mix = write_reg32(USDHC_MIX_CTRL_OFFSET, mix_ctrl);

  return 0;
}

fun setup_write_dma(1 dma_addr, 1 sector_count) {
  var 1 write_dma = write_reg32(USDHC_DS_ADDR_OFFSET, dma_addr);

  var 1 blk_att = read_reg32(USDHC_BLK_ATT_OFFSET);
  /* Clear BLKSIZE (keep upper 16 bits) */
  blk_att = blk_att & 4294901760;
  blk_att = blk_att | SD_BLOCK_SIZE;
  /* Clear BLKCNT (keep lower 16 bits) */
  blk_att = blk_att & 65535;
  blk_att = blk_att | (sector_count << 16);
  var 1 write_blk = write_reg32(USDHC_BLK_ATT_OFFSET, blk_att);

  var 1 mix_ctrl = read_reg32(USDHC_MIX_CTRL_OFFSET);
  mix_ctrl = mix_ctrl & USDHC_MIX_CTRL_DTDSEL_INV;
  var 1 write_mix = write_reg32(USDHC_MIX_CTRL_OFFSET, mix_ctrl);

  return 0;
}

/* ========== Core Functions: Client Request Handling ========== */

/*
 * Process block queue requests when driver is active
 * Returns: 0 = success, 1 = still processing, MAX_INT32 = error
 */
fun process_blk_request(1 was_irq) {
  var driver_status = DRIVER_STATUS;

  /* Don't process during bringup */
  if (driver_status == DRV_STATUS_BRINGUP) {
    return 0;
  }

  var req_inflight = BLK_REQ_INFLIGHT;

  /* If not from IRQ and have inflight request, skip dequeue */
  if (was_irq == 0 && req_inflight != 0) {
    return 0;
  }

  /* If no inflight request and not from IRQ, try to dequeue */
  if (was_irq == 0 && req_inflight == 0) {
    if (driver_status == DRV_STATUS_INACTIVE) {
      return MAX_INT32;
    }

    var 1 err = blk_dequeue_req();
    if (err != 0) {
      return 0;
    }

    /* Mark request as inflight */
    st pnk_mem_ptr(6), 1;
  }

  /* Re-check inflight after potential dequeue */
  req_inflight = BLK_REQ_INFLIGHT;
  if (req_inflight == 0) {
    return 0;
  }

  /* Process the request */
  var code = BLK_REQ_CODE;
  var response_status = 0;
  var success_count = 0;

  if (code == BLK_REQ_FLUSH || code == BLK_REQ_BARRIER) {
    /* No-ops */
    response_status = BLK_RESP_OK;
    success_count = 0;
  }

  if (code == BLK_REQ_READ || code == BLK_REQ_WRITE) {
    return MAX_INT32;
  }

  /* Unknown code */
  if (code != BLK_REQ_FLUSH && code != BLK_REQ_BARRIER && code != BLK_REQ_READ && code != BLK_REQ_WRITE) {
    response_status = BLK_RESP_ERR_INVALID_PARAM;
    success_count = 0;
  }

  /* Enqueue response */
  var 1 enq_err = blk_enqueue_resp(response_status, success_count);
  if (enq_err != 0) {
    return 1;
  }

  /* Notify virtualizer */
  microkit_notify(virt_ch)

  /* Mark request as complete */
  st pnk_mem_ptr(6), 0;

  return 0;
}

/* ========== Export: Main Entry Point ========== */

export fun notified(1 ch) {
  var driver_status = DRIVER_STATUS;

  /* Handle IRQ during bringup - delegate to C */
  if (driver_status == DRV_STATUS_BRINGUP) {
    if (ch == irq_ch) {
      /* Call C bringup handler */
      @DoBringup(0, 0, 0, 0);
      microkit_deferred_irq_ack(ch)
    }
    return 0;
  }

  /* Handle IRQ in active/inactive state */
  if (ch == irq_ch) {
    var 1 result = process_blk_request(1);

    if (result == MAX_INT32) {
      @HandleClient(0, 1, 0, 0);
    }

    microkit_deferred_irq_ack(ch)
    return 0;
  }

  /* Handle virtualizer notification */
  if (ch == virt_ch) {
    var 1 result = process_blk_request(0);

    if (result == MAX_INT32) {
      @HandleClient(0, 0, 0, 0);
    }

    return 0;
  }

  return 0;
}

/* ========== Export: Main Entry (called from C init) ========== */

fun main() {
  /* Initialization complete, ready to process requests */
  return 0;
}
