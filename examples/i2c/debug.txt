fun i2c_queue_empty(1 queue_ptr)
{
  var tail = 0;
  var head = 0;
  !ld32 tail, queue_ptr;
  !ld32 head, queue_ptr + 4;
  var diff = tail - head;
  var empty = (diff == 0);
  return empty;
}
fun i2c_queue_full(1 queue_ptr)
{
  var tail = 0;
  var head = 0;
  !ld32 tail, queue_ptr;
  !ld32 head, queue_ptr + 4;
  var diff = tail - head + 1;
  var full = (diff == 32);
  return full;
}
fun i2c_queue_length(1 queue_ptr)
{
  var tail = 0;
  var head = 0;
  !ld32 tail, queue_ptr;
  !ld32 head, queue_ptr + 4;
  var length = tail - head;
  return length;
}
fun i2c_enqueue(1 queue_ptr, 1 bus_address, 1 offset, 1 len)
{
  var 1 is_full = i2c_queue_full(queue_ptr);
  if (is_full) {
    return -1;
  }
  var tail = 0;
  !ld32 tail, queue_ptr;
  var index = tail & (32 - 1);
  var entry_base = queue_ptr + 8 + index * 24;
  !stw entry_base, offset;
  !st32 entry_base + 8, len;
  !stw entry_base + 16, bus_address;
  @THREAD_MEMORY_RELEASE(0,0,0,0);
  tail = tail + 1;
  !st32 queue_ptr, tail;
  return 0;
}
fun i2c_dequeue(1 queue_ptr)
{
  var 1 is_empty = i2c_queue_empty(queue_ptr);
  if (is_empty) {
    return <-1, 0, 0, 0>;
  }
  var head = 0;
  !ld32 head, queue_ptr + 4;
  var index = head & (32 - 1);
  var entry_base = queue_ptr + 8 + index * 24;
  var offset = 0;
  var len = 0;
  var bus_address = 0;
  !ldw offset, entry_base;
  !ld32 len, entry_base + 8;
  !ldw bus_address, entry_base + 16;
  @THREAD_MEMORY_RELEASE(0,0,0,0);
  head = head + 1;
  !st32 queue_ptr + 4, head;
  return <0, bus_address, offset, len>;
}
fun i2c_enqueue_request(1 req_queue_ptr, 1 bus_address, 1 offset, 1 len)
{
  var 1 result = i2c_enqueue(req_queue_ptr, bus_address, offset, len);
  return result;
}
fun i2c_enqueue_response(1 resp_queue_ptr, 1 bus_address, 1 offset, 1 len)
{
  var 1 result = i2c_enqueue(resp_queue_ptr, bus_address, offset, len);
  return result;
}
fun i2c_dequeue_request(1 req_queue_ptr)
{
  var {1,1,1,1} result = i2c_dequeue(req_queue_ptr);
  return result;
}
fun i2c_dequeue_response(1 resp_queue_ptr)
{
  var {1,1,1,1} result = i2c_dequeue(resp_queue_ptr);
  return result;
}
var 1 g_curr_data = 0;
var 1 g_curr_request_len = 0;
var 1 g_curr_response_len = 0;
var 1 g_remaining = 0;
var 1 g_notified = 0;
var 1 g_rw_remaining = 0;
var 1 g_data_direction = 0;
var 1 g_addr = 0;
var 1 g_request_queue_ptr = 0;
var 1 g_response_queue_ptr = 0;
var 1 g_ctl_reg_addr = 0;
var 1 g_addr_reg_addr = 0;
var 1 g_tk_list0_addr = 0;
var 1 g_tk_list1_addr = 0;
var 1 g_wdata0_addr = 0;
var 1 g_wdata1_addr = 0;
var 1 g_rdata0_addr = 0;
var 1 g_rdata1_addr = 0;
fun init_globals() {
    var handle_ptr = (@base + (4) * @biw);
    !ldw g_request_queue_ptr, handle_ptr;
    var response_ptr_addr = handle_ptr + 8;
    !ldw g_response_queue_ptr, response_ptr_addr;
    var base_reg = (lds 1 (@base + (0) * @biw));
    g_ctl_reg_addr = base_reg + 0;
    g_addr_reg_addr = base_reg + 4;
    g_tk_list0_addr = base_reg + 8;
    g_tk_list1_addr = base_reg + 12;
    g_wdata0_addr = base_reg + 16;
    g_wdata1_addr = base_reg + 20;
    g_rdata0_addr = base_reg + 24;
    g_rdata1_addr = base_reg + 28;
    return 0;
}
fun get_queue_head(1 queue_ptr) {
    var head_addr = queue_ptr + 4;
    var head = 0;
    !ld32 head, head_addr;
    return head;
}
fun set_queue_head(1 queue_ptr, 1 head) {
    var head_addr = queue_ptr + 4;
    !st32 head_addr, head;
    return 0;
}
fun get_queue_tail(1 queue_ptr) {
    var tail_addr = queue_ptr + 0;
    var tail = 0;
    !ld32 tail, tail_addr;
    return tail;
}
fun set_queue_tail(1 queue_ptr, 1 tail) {
    var tail_addr = queue_ptr + 0;
    !st32 tail_addr, tail;
    return 0;
}
fun get_entry_offset(1 queue_ptr, 1 index) {
    var entry_base = queue_ptr + 8 + (index * 24);
    var offset = 0;
    !ldw offset, entry_base;
    return offset;
}
fun set_entry_offset(1 queue_ptr, 1 index, 1 offset) {
    var entry_base = queue_ptr + 8 + (index * 24);
    !stw entry_base, offset;
    return 0;
}
fun get_entry_len(1 queue_ptr, 1 index) {
    var entry_base = queue_ptr + 8 + (index * 24) + 8;
    var len = 0;
    !ld32 len, entry_base;
    return len;
}
fun set_entry_len(1 queue_ptr, 1 index, 1 len) {
    var entry_base = queue_ptr + 8 + (index * 24) + 8;
    !st32 entry_base, len;
    return 0;
}
fun get_entry_bus_address(1 queue_ptr, 1 index) {
    var entry_base = queue_ptr + 8 + (index * 24) + 16;
    var bus_address = 0;
    !ldw bus_address, entry_base;
    return bus_address;
}
fun set_entry_bus_address(1 queue_ptr, 1 index, 1 bus_address) {
    var entry_base = queue_ptr + 8 + (index * 24) + 16;
    !stw entry_base, bus_address;
    return 0;
}
fun i2c_queue_empty_pnk(1 queue_ptr) {
    var 1 head = get_queue_head(queue_ptr);
    var 1 tail = get_queue_tail(queue_ptr);
    var diff = tail - head;
    if (diff == 0) {
        return 1;
    }
    return 0;
}
fun i2c_queue_full_pnk(1 queue_ptr) {
    var 1 head = get_queue_head(queue_ptr);
    var 1 tail = get_queue_tail(queue_ptr);
    var diff = tail - head + 1;
    if (diff == 32) {
        return 1;
    }
    return 0;
}
fun i2c_enqueue_pnk(1 queue_ptr, 1 bus_address, 1 offset, 1 len) {
    var 1 is_full = i2c_queue_full_pnk(queue_ptr);
    if (is_full) {
        return 1;
    }
    var 1 tail = get_queue_tail(queue_ptr);
    var index = tail & (32 - 1);
    set_entry_bus_address(queue_ptr, index, bus_address);
    set_entry_offset(queue_ptr, index, offset);
    set_entry_len(queue_ptr, index, len);
    @THREAD_MEMORY_RELEASE(0,0,0,0);
    var new_tail = tail + 1;
    set_queue_tail(queue_ptr, new_tail);
    return 0;
}
fun i2c_dequeue_pnk(1 queue_ptr) {
    var 1 is_empty = i2c_queue_empty_pnk(queue_ptr);
    if (is_empty) {
        return <1, 0, 0, 0>;
    }
    var 1 head = get_queue_head(queue_ptr);
    var index = head & (32 - 1);
    var 1 bus_address = get_entry_bus_address(queue_ptr, index);
    var 1 offset = get_entry_offset(queue_ptr, index);
    var 1 len = get_entry_len(queue_ptr, index);
    @THREAD_MEMORY_RELEASE(0,0,0,0);
    var new_head = head + 1;
    set_queue_head(queue_ptr, new_head);
    return <0, bus_address, offset, len>;
}
fun get_i2c_error() {
    var ctl = 0;
    !ld32 ctl, g_ctl_reg_addr;
    var err = ctl & (1 << 3);
    var bytes_read = (ctl >> 8) & 15;
    var curr_token = (ctl >> 4) & 15;
    return <err, bytes_read, curr_token>;
}
fun i2c_halt() {
    var ctl = 0;
    !ld32 ctl, g_ctl_reg_addr;
    ctl = ctl & 4294967294;
    !st32 g_ctl_reg_addr, ctl;
    return 0;
}
fun handle_response() {
    var 3 error_info = get_i2c_error();
    var write_error = error_info.0;
    var bytes_read = error_info.1;
    var curr_token = error_info.2;
    var return_buffer = g_curr_data;
    if (write_error) {
        var err_addr = return_buffer + 0;
        var token_addr = return_buffer + 1;
        if (curr_token == 3) {
            !st8 err_addr, 3;
        } else {
            !st8 err_addr, 2;
        }
        !st8 token_addr, curr_token;
    } else {
        var bytes_copied = 0;
        while (bytes_copied < bytes_read) {
            var curr_resp_len = g_curr_response_len;
            var index = 2 + curr_resp_len;
            var value = 0;
            if (bytes_copied < 4) {
                var byte_addr = g_rdata0_addr + bytes_copied;
                !ld8 value, byte_addr;
            } else {
                if (bytes_copied < 8) {
                    var byte_addr = g_rdata1_addr + (bytes_copied - 4);
                    !ld8 value, byte_addr;
                }
            }
            var data_addr = return_buffer + index;
            !st8 data_addr, value;
            var new_resp_len = g_curr_response_len + 1;
            g_curr_response_len = new_resp_len;
            bytes_copied = bytes_copied + 1;
        }
        var err_addr = return_buffer + 0;
        var token_addr = return_buffer + 1;
        !st8 err_addr, 0;
        !st8 token_addr, 0;
    }
    var remaining = g_remaining;
    if (write_error || remaining == 0) {
        var 1 resp_queue_ptr = g_response_queue_ptr;
        var bus_address = g_addr;
        var curr_data = g_curr_data;
        var base_data_addr = (lds 1 (@base + (21) * @biw));
        var offset = curr_data - base_data_addr;
        var response_len = g_curr_response_len + 2;
        i2c_enqueue_pnk(resp_queue_ptr, bus_address, offset, response_len);
        g_curr_response_len = 0;
        g_curr_data = 0;
        g_curr_request_len = 0;
        g_remaining = 0;
        g_addr = 0;
        @microkit_notify_virt(0,0,0,0);
        i2c_halt();
    }
    var remaining_check = g_remaining;
    var notified_check = g_notified;
    if (remaining_check > 0) {
        i2c_load_tokens();
    } else {
        if (notified_check > 0) {
            handle_request();
        }
    }
    return 0;
}
fun token_shift_left(1 token, 1 tk_offset) {
    if (tk_offset == 0) { return token << 0; }
    if (tk_offset == 1) { return token << 4; }
    if (tk_offset == 2) { return token << 8; }
    if (tk_offset == 3) { return token << 12; }
    if (tk_offset == 4) { return token << 16; }
    if (tk_offset == 5) { return token << 20; }
    if (tk_offset == 6) { return token << 24; }
    if (tk_offset == 7) { return token << 28; }
    return 0;
}
fun data_shift_left(1 data, 1 wdata_offset) {
    if (wdata_offset == 0) { return data << 0; }
    if (wdata_offset == 1) { return data << 8; }
    if (wdata_offset == 2) { return data << 16; }
    if (wdata_offset == 3) { return data << 24; }
    return 0;
}
fun convert_token(1 token) {
    if (token == 0) { return 0; }
    if (token == 1) { return 1; }
    if (token == 2) {
        g_data_direction = 0;
        return 2;
    }
    if (token == 3) {
        g_data_direction = 1;
        return 3;
    }
    if (token == 4) { return 6; }
    return 0;
}
fun i2c_load_tokens() {
    var tokens = g_curr_data;
    var remaining = g_remaining;
    var curr_request_len = g_curr_request_len;
    var addr_reg = 0;
    !ld32 addr_reg, g_addr_reg_addr;
    addr_reg = addr_reg & 4294967040;
    var device_addr = (g_addr & 127) * 2;
    addr_reg = addr_reg | device_addr;
    !st32 g_addr_reg_addr, addr_reg;
    !st32 g_tk_list0_addr, 0;
    !st32 g_tk_list1_addr, 0;
    !st32 g_wdata0_addr, 0;
    !st32 g_wdata1_addr, 0;
    var tk_offset = 0;
    var wdata_offset = 0;
    var rdata_offset = 0;
    var request_data_offset = curr_request_len - remaining;
    while (tk_offset < 16 && wdata_offset < 8 && rdata_offset < 8 && request_data_offset < curr_request_len) {
        var meson_token = 0;
        var data = 0;
        var rw_remaining = g_rw_remaining;
        if (rw_remaining == 0) {
            var token_addr = tokens + request_data_offset;
            var token = 0;
            !ld8 token, token_addr;
            var 1 converted_token = convert_token(token);
            meson_token = converted_token;
            if (meson_token == 2 || meson_token == 3) {
                var len_addr = tokens + request_data_offset + 1;
                var buff_length = 0;
                !ld8 buff_length, len_addr;
                g_rw_remaining = buff_length;
                if (meson_token == 2) {
                    g_data_direction = 0;
                } else {
                    g_data_direction = 1;
                }
                request_data_offset = request_data_offset + 1;
            }
        } else {
            var data_direction = g_data_direction;
            if (rw_remaining == 1 && data_direction == 1) {
                meson_token = 5;
            } else {
                meson_token = 4;
            }
            if (data_direction == 0) {
                var data_addr = tokens + request_data_offset;
                !ld8 data, data_addr;
            }
            var new_rw_remaining = rw_remaining - 1;
            g_rw_remaining = new_rw_remaining;
        }
        if (tk_offset < 8) {
            var tk_list0 = 0;
            !ld32 tk_list0, g_tk_list0_addr;
            var 1 shifted_token = token_shift_left(meson_token, tk_offset);
            tk_list0 = tk_list0 | shifted_token;
            !st32 g_tk_list0_addr, tk_list0;
        } else {
            var tk_list1 = 0;
            !ld32 tk_list1, g_tk_list1_addr;
            var offset_mod8 = tk_offset - 8;
            var 1 shifted_token = token_shift_left(meson_token, offset_mod8);
            tk_list1 = tk_list1 | shifted_token;
            !st32 g_tk_list1_addr, tk_list1;
        }
        tk_offset = tk_offset + 1;
        var data_direction_check = g_data_direction;
        if (meson_token == 4 && data_direction_check == 0) {
            if (wdata_offset < 4) {
                var wdata0 = 0;
                !ld32 wdata0, g_wdata0_addr;
                var 1 shifted_data = data_shift_left(data, wdata_offset);
                wdata0 = wdata0 | shifted_data;
                !st32 g_wdata0_addr, wdata0;
            } else {
                var wdata1 = 0;
                !ld32 wdata1, g_wdata1_addr;
                var offset_minus4 = wdata_offset - 4;
                var 1 shifted_data = data_shift_left(data, offset_minus4);
                wdata1 = wdata1 | shifted_data;
                !st32 g_wdata1_addr, wdata1;
            }
            wdata_offset = wdata_offset + 1;
        }
        if ((meson_token == 4 || meson_token == 5)
            && data_direction_check == 1) {
            rdata_offset = rdata_offset + 1;
        }
        request_data_offset = request_data_offset + 1;
    }
    var new_remaining = curr_request_len - request_data_offset;
    g_remaining = new_remaining;
    i2c_start();
    return 0;
}
fun i2c_start() {
    var ctl = 0;
    !ld32 ctl, g_ctl_reg_addr;
    ctl = ctl & 4294967294;
    !st32 g_ctl_reg_addr, ctl;
    ctl = ctl | 1;
    !st32 g_ctl_reg_addr, ctl;
    return 0;
}
fun handle_request() {
    var 1 queue_empty = i2c_queue_empty_pnk(g_request_queue_ptr);
    if (queue_empty == 0) {
        var curr_data = g_curr_data;
        if (curr_data != 0) {
            g_notified = 1;
            return 0;
        }
        var 4 dequeue_result = i2c_dequeue_pnk(g_request_queue_ptr);
        var err = dequeue_result.0;
        var bus_address = dequeue_result.1;
        var offset = dequeue_result.2;
        var size = dequeue_result.3;
        if (err != 0) {
            return 0;
        }
        if (size > 128) {
            return 0;
        }
        if (bus_address > 127) {
            return 0;
        }
        var base_data_addr = (lds 1 (@base + (21) * @biw));
        var curr_data_addr = base_data_addr + offset;
        g_curr_data = curr_data_addr;
        g_addr = bus_address;
        g_curr_request_len = size;
        g_remaining = size;
        g_notified = 0;
        i2c_load_tokens();
    } else {
        g_notified = 0;
    }
    return 0;
}
fun main() {
    init_globals();
    return 0;
}
export fun notified(1 ch) {
    var virt = (lds 1 (@base + (3) * @biw));
    var irq0 = (lds 1 (@base + (1) * @biw));
    var irq1 = (lds 1 (@base + (2) * @biw));
    if (ch == virt) {
        handle_request();
    } else {
        if (ch == irq0) {
            handle_response();
            @microkit_deferred_irq_ack(0,ch,0,0);
        } else {
            if (ch == irq1) {
                @handle_response_timeout(0,0,0,0);
                @microkit_deferred_irq_ack(0,ch,0,0);
            } else {
            }
        }
    }
    return 0;
}
